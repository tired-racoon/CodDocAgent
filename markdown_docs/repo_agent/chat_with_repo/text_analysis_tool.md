## ClassDef TextAnalysisTool
**TextAnalysisTool**: класс для анализа текста и взаимодействия с языковой моделью.

**Attributes**:
- параметр 1: `llm` — языковая модель для выполнения запросов (`FunctionCallingLLM`);
- параметр 2: `db_path` — путь к базе данных для поиска и обработки информации (`str`).

**Описание кода**:

Класс `TextAnalysisTool` предназначен для анализа текста и взаимодействия с языковой моделью. В конструкторе (`__init__`) класса инициализируются атрибуты:
- `jsonsearch` — экземпляр класса `JsonFileProcessor` для работы с файлами JSON;
- `llm` — языковая модель;
- `db_path` — путь к базе данных.

Методы класса:
- `keyword(query)` — возвращает список ключевых слов для заданного запроса;
- `tree(query)` — генерирует древовидную структуру на основе анализа текста;
- `format_chat_prompt(message, instruction)` — формирует шаблон для чата;
- `queryblock(message)` — ищет содержимое кода по имени и возвращает результаты поиска;
- `list_to_markdown(search_result)` — преобразует список в формат Markdown;
- `nerquery(message)` — извлекает наиболее релевантное имя класса или функции на основе заданного запроса.

Класс `TextAnalysisTool` используется в сочетании с другими компонентами для анализа текста и взаимодействия с языковой моделью. Например, в классе `RepoAssistant` экземпляр `TextAnalysisTool` используется для анализа содержимого репозитория и взаимодействия с языковой моделью при работе с данными.

**Примечание**:
При использовании класса `TextAnalysisTool` необходимо убедиться, что путь к базе данных (`db_path`) корректен и доступен для чтения. Также важно учитывать ограничения на количество возвращаемых ключевых слов и формат вывода при использовании метода `keyword`.

**Пример вывода**:
```
search_result, md = text_analysis_tool.queryblock(message)
markdown_str = text_analysis_tool.list_to_markdown(search_result)
```
### FunctionDef __init__(self, db_path)
**__init__**: Функция __init__ инициализирует объект TextAnalysisTool, устанавливая необходимые внутренние атрибуты.

**parameters**:
* параметр 1: llm — экземпляр класса FunctionCallingLLM, представляющий модель для обработки естественного языка.
* параметр 2: db_path — строка, указывающая путь к базе данных в формате JSON.

**Описание кода**:
Функция __init__ принимает два параметра: модель для обработки естественного языка (llm) и путь к базе данных (db_path). Внутри функции создаются три атрибута:
* self.jsonsearch — экземпляр класса JsonFileProcessor, который используется для обработки файлов в формате JSON по указанному пути (db_path).
* self.llm — переданный экземпляр модели для обработки естественного языка.
* self.db_path — путь к базе данных, переданный в качестве параметра.

**Примечание**:
При использовании TextAnalysisTool необходимо убедиться, что модель llm и путь к базе данных db_path корректны и доступны.
***
### FunctionDef keyword(self, query)
**keyword**: Функция keyword извлекает список ключевых слов из текста запроса.

**parameters**:
- параметр 1: `query` — строка, содержащая запрос, на основе которого нужно извлечь ключевые слова.

**Описание кода**:
Функция `keyword` использует модель обработки естественного языка (`llm`) для генерации списка ключевых слов на основе переданного запроса. В запросе можно указать не более трёх ключевых слов. Функция формирует подсказку для модели `llm` с помощью форматированной строки, которая включает исходный запрос, и передаёт эту подсказку модели для обработки. Затем функция возвращает полученный от модели ответ.

Функция `keyword` вызывается в контексте обработки пользовательских запросов в системе, где требуется анализ текста для определения ключевых слов. Это может быть полезно для различных задач, связанных с анализом естественного языка, например, для улучшения релевантности поисковых запросов или для извлечения ключевых концепций из текстовых документов.

**Примечание**:
При использовании функции `keyword` важно учитывать, что модель может генерировать различные результаты в зависимости от контекста и формулировки запроса. Также следует помнить, что функция ограничена тремя ключевыми словами в ответе.

**Пример вывода**:
```
Generated keywords from prompt: ["ключевое", "слово", "анализ"]
```
***
### FunctionDef tree(self, query)
**tree**: Функция `tree` принимает текстовый запрос и возвращает структуру дерева, основанную на иерархии, сгенерированной языковой моделью.

**parameters**:
* параметр 1: `query` — текст, который нужно проанализировать и на основе которого сгенерировать структуру дерева.

**Описание кода**: Функция `tree` использует языковую модель (`llm`) для генерации структуры дерева на основе текста. Она формирует запрос к модели, добавляя текст для анализа, и получает ответ от модели. Затем возвращает этот ответ.

Функция `tree` вызывается объектом, который работает с файлами в репозитории и использует методы для получения версий файлов. Это позволяет анализировать изменения в файлах и генерировать соответствующие структуры дерева.

**Примечание**: При использовании функции `tree` важно убедиться, что языковая модель (`llm`) правильно настроена и доступна для выполнения запросов. Также необходимо учитывать, что ответ от модели может зависеть от её настроек и параметров.

**Пример вывода**:
```
Please analyze the following text and generate a tree structure based on its hierarchy:

[ваш текст]
```
Ответ модели будет представлен в виде структуры дерева, основанной на иерархии текста.
***
### FunctionDef format_chat_prompt(self, message, instruction)
**format_chat_prompt**: Функция format_chat_prompt формирует строку с инструкцией и сообщением пользователя для дальнейшего использования в диалоге.

**parameters**:
- параметр 1: `message` — сообщение пользователя.
- параметр 2: `instruction` — инструкция для системы.

**Описание кода**:
Функция `format_chat_prompt` принимает два параметра: `message` (сообщение пользователя) и `instruction` (инструкция для системы). Она формирует строку `prompt`, которая включает в себя инструкцию, сообщение пользователя и метку для ответа ассистента. Для этого используется f-строка, в которой элементы объединяются с помощью символов `\n` для создания многострочного текста.

Возвращаемое значение функции — это строка `prompt`, которая будет использоваться в дальнейшем диалоге.

Функция `format_chat_prompt` вызывается в методе `respond` класса `RepoAssistant`. В этом методе формируется запрос к векторному хранилищу, генерируются дополнительные запросы и формируется ответ на основе полученных данных.

**Примечание**:
При использовании функции `format_chat_prompt` важно правильно задать параметры `message` и `instruction`, чтобы получить ожидаемый результат.

**Пример вывода**:
```
prompt = format_chat_prompt("Привет, как дела?", "Поприветствовать и узнать, как дела.")
print(prompt)
```
Вывод:
```
System: Поприветствовать и узнать, как дела.
User: Привет, как дела?
Assistant: 
```
***
### FunctionDef queryblock(self, message)
**queryblock**: Функция `queryblock` выполняет поиск по содержимому кода в базе данных на основе переданного запроса.

**parameters**:
* `message` — строка с запросом для поиска в содержимом кода.

**Описание кода**:
Функция `queryblock` использует метод `search_code_contents_by_name` объекта `jsonsearch` для поиска в базе данных (`db_path`), используя `message` в качестве поискового запроса. Найденные результаты поиска и метаданные возвращаются в виде кортежа.

Этот метод вызывается в контексте обработки пользовательского запроса в системе, которая взаимодействует с векторным хранилищем и использует алгоритмы ранжирования для формирования ответа. `queryblock` помогает в извлечении релевантных фрагментов кода на основе ключевых слов, извлечённых из пользовательского запроса.

**Примечание**:
При использовании `queryblock` важно убедиться, что `message` содержит чёткий запрос, который можно использовать для поиска в базе данных. Также следует учитывать, что результаты поиска могут быть обработаны дополнительными алгоритмами для ранжирования и формирования окончательного ответа.

**Пример вывода**:
```
search_result, md = queryblock(message)
```
***
### FunctionDef list_to_markdown(self, search_result)
**list_to_markdown**: Функция list_to_markdown преобразует список элементов в строку в формате Markdown.

**parameters**:
* параметр 1: search_result — список элементов, которые нужно преобразовать.

**Описание кода**:
Функция list_to_markdown принимает на вход список search_result и преобразует каждый элемент этого списка в отдельную строку в формате Markdown. Нумерация строк начинается с 1. После каждого элемента добавляется символ новой строки.

**Примечание**:
При использовании функции list_to_markdown убедитесь, что список search_result содержит элементы, которые вы хотите преобразовать в формат Markdown.

**Пример вывода**:
Предположим, что search_result содержит следующие элементы: ["элемент 1", "элемент 2", "элемент 3"]. Тогда функция вернёт строку в формате Markdown:
```
1. элемент 1

2. элемент 2

3. элемент 3
```
***
### FunctionDef nerquery(self, message)
**nerquery**: Функция `nerquery` выполняет извлечение наиболее релевантного класса или функции на основе заданного запроса.

**parameters**:
- `message`: входной текст, на основе которого производится извлечение.

**Описание кода**: Функция `nerquery` формирует запрос к языковой модели `llm` для извлечения наиболее релевантного класса или функции. Запрос содержит инструкцию по извлечению и сам входной текст. Результат возвращается в виде строки с именем функции или класса. Функция используется в контексте обработки пользовательских запросов и поиска релевантной информации в хранилище векторов.

**Примечание**: При использовании функции `nerquery` необходимо учитывать, что результат должен содержать только одно имя функции или класса без дополнительных символов.

**Пример вывода**:
```
"Pure function names: calculateSum, processData
Pure class names: MyClass, DataProcessor"
```
***
