## ClassDef CallGraphBuilder
**CallGraphBuilder**: Класс CallGraphBuilder предназначен для построения графа вызовов функций в исходном коде, написанном на различных языках программирования (Python, Go, Java, Kotlin).

**Attributes**:
* параметр 1: `repo_path` — путь к репозиторию, в котором будут анализироваться файлы.
* параметр 2: `call_graph` — словарь, в котором хранятся данные о вызовах функций и функциях, которые их вызывают.

**Описание кода**:

Класс CallGraphBuilder используется для анализа исходного кода и построения графа вызовов функций. В конструкторе класса задаётся путь к репозиторию, который будет анализироваться. Метод `extract_functions_and_calls` анализирует дерево синтаксического анализа исходного кода и извлекает информацию о функциях и вызовах. Метод `process_file` обрабатывает отдельный файл, а метод `build_from_repo` обрабатывает все файлы в репозитории. Метод `get_call_graph` возвращает построенный граф вызовов.

Метод `extract_functions_and_calls` принимает на вход корень дерева синтаксического анализа (`root`), язык программирования (`language`), исходный код (`code`) и путь к файлу (`file_path`). Метод обходит дерево синтаксического анализа и извлекает информацию о функциях и вызовах. Для этого используется рекурсивная функция `walk`.

Метод `_extract_function_name` извлекает имя функции из узла дерева синтаксического анализа. Метод `_get_node_text` извлекает текст узла дерева синтаксического анализа.

Метод `process_file` анализирует отдельный файл. Для этого используется экземпляр класса `TreeSitterParser`, который парсит файл и возвращает его корень. Затем метод вызывает метод `extract_functions_and_calls` для извлечения информации о функциях и вызовах.

Метод `build_from_repo` обрабатывает все файлы в репозитории. Для этого используется функция `os.walk`, которая обходит все файлы в репозитории. Для каждого файла метод вызывает метод `process_file`.

Метод `get_call_graph` возвращает построенный граф вызовов.

**Примечание**:
При использовании класса CallGraphBuilder необходимо убедиться, что путь к репозиторию указан корректно, а исходный код соответствует ожидаемому формату. Также необходимо учитывать, что метод `extract_functions_and_calls` может не обрабатывать все случаи, поэтому результаты могут быть неполными.

**Пример вывода**:

Граф вызовов представляет собой словарь, в котором ключами являются имена функций, а значениями — словари с информацией о вызовах и функциях, которые их вызывают. Например:

```
{
    "func1": {
        "calls": {"func2"},
        "called_by": {"func3"}
    },
    "func2": {
        "calls": {},
        "called_by": {"func1"}
    },
    "func3": {
        "calls": {"func2"},
        "called_by": {}
    }
}
```
### FunctionDef __init__(self)
**__init__**: Функция __init__ инициализирует объект CallGraphBuilder и устанавливает путь к репозиторию.

**parameters**:
* параметр 1: repo_path (str)

**Описание кода**:
Функция __init__ принимает один параметр repo_path, который является путём к репозиторию в виде строки. Этот путь сохраняется в атрибуте self.repo_path объекта CallGraphBuilder. Также создаётся словарь call_graph с помощью defaultdict, где каждому ключу соответствует словарь с двумя ключами: calls (множество вызовов) и called_by (множество вызывающих).

**Примечание**:
Обратите внимание, что call_graph инициализируется как defaultdict, что позволяет удобно добавлять новые ключи без проверки их существования. Это может быть полезно при построении графа вызовов.
***
### FunctionDef extract_functions_and_calls(self)
**extract_functions_and_calls**: Функция `extract_functions_and_calls` извлекает из заданного кода функции и вызовы функций.

**parameters**:
* параметр 1: `root` (объект `Node`)
* параметр 2: `language` (строка)
* параметр 3: `code` (данные в формате `bytes`)
* параметр 4: `file_path` (строка)

**Описание кода**:
Функция `extract_functions_and_calls` проходит по дереву синтаксического анализа (`root`), которое было создано на основе заданного кода (`code`) и языка программирования (`language`). Для каждого узла проверяется его тип и, в зависимости от языка программирования, извлекаются имена функций и методы.

Если узел представляет собой определение функции или класса в Python, объявление функции в Go, объявление метода в Java, Kotlin или функцию в Java, Kotlin, то имя функции сохраняется в список `functions`. Также сохраняется начало и конец строки, в которой определена функция.

Если узел представляет собой вызов функции, то имя вызываемой функции сохраняется в список `calls` вместе с именем функции, которая делает вызов.

Для обхода дерева используется рекурсивная функция `walk`, которая вызывается для каждого дочернего узла.

После завершения обхода дерева возвращается кортеж, содержащий список функций и список вызовов.

**Примечание**:
При использовании функции `extract_functions_and_calls` важно убедиться, что дерево синтаксического анализа (`root`), язык программирования (`language`), код (`code`) и путь к файлу (`file_path`) корректно заданы и соответствуют ожидаемому формату. Некорректное использование может привести к ошибкам или неправильному извлечению информации.
***
### FunctionDef _extract_function_name(self)
**__extract_function_name_**: Функция `_extract_function_name` извлекает имя функции или метода из заданного узла в структуре кода.

**parameters**:
* параметр 1: `node` (объект `Node`)
* параметр 2: `code` (данные в формате `bytes`)

**Описание кода**:
Функция `_extract_function_name` анализирует заданный узел (`node`) в структуре кода и извлекает имя функции или метода. В зависимости от типа узла (`node.type`) функция использует различные подходы для извлечения имени:
* Если `node` представляет собой `selector_expression` или `member_expression`, функция рекурсивно вызывает себя для извлечения имён объекта и поля/оператора, а затем объединяет их в строку.
* Если `node` представляет собой `method_invocation`, функция возвращает текст узла, который содержит имя метода.
* Если `node` представляет собой `call_expression` (специальная обработка для Kotlin), функция возвращает текст узла, который содержит имя функции.
* Если `node` представляет собой `identifier`, функция возвращает текст узла.
* В противном случае функция возвращает текст узла.

Функция `_extract_function_name` используется в контексте анализа структуры кода, например, для извлечения имён функций и методов при парсинге программ на разных языках программирования.

**Примечание**:
При использовании функции `_extract_function_name` важно убедиться, что узел (`node`) и данные кода (`code`) корректно заданы и соответствуют ожидаемому формату. Некорректное использование может привести к ошибкам или неправильному извлечению имени функции/метода.
***
### FunctionDef _get_node_text(self, node)
**_get_node_text_**: Функция _get_node_text извлекает текст узла из заданного диапазона байтов в строке кода.

**parameters**:
- параметр 1: **node** (объект Node)
- параметр 2: **code** (данные в формате bytes)

**Описание кода**:
Функция _get_node_text принимает два аргумента: узел (node) и данные кода (code) в формате bytes. Если узел (node) не задан или равен None, функция возвращает None. В противном случае функция возвращает строку, полученную путём декодирования среза данных кода (code) от начального байта узла (node.start_byte) до конечного байта узла (node.end_byte) в кодировке UTF-8.

Функция _get_node_text используется в контексте анализа структуры кода, например, для извлечения имён функций и методов. Она позволяет получить текст, соответствующий определённому узлу в структуре кода, что может быть полезно при парсинге и анализе программ на разных языках программирования.

**Примечание**:
При использовании функции _get_node_text важно убедиться, что узел (node) и данные кода (code) корректно заданы и соответствуют ожидаемому формату. Некорректное использование может привести к ошибкам декодирования или неправильному извлечению текста узла.
***
### FunctionDef process_file(self)
**process_file**: Функция `process_file` обрабатывает файл, анализируя его содержимое и извлекая информацию о функциях и вызовах функций.

**parameters**:
* параметр 1: `file_path` (строка) — путь к файлу, который нужно обработать;
* параметр 2: `language` (строка) — язык программирования, на котором написан файл.

**Описание кода**:
Функция `process_file` выполняет следующие действия:
1. Создаёт экземпляр класса `TreeSitterParser` с указанием языка программирования.
2. Использует созданный экземпляр для синтаксического анализа файла и получения корневого узла дерева разбора (`root`).
3. Читает содержимое файла в переменную `code`.
4. Вызывает функцию `extract_functions_and_calls` для извлечения из `root`, `language`, `code` и `file_path` информации о функциях и вызовах функций.
5. Для каждой функции в списке `functions` сохраняет информацию о её расположении в файле в словаре `self.call_graph`.
6. Для каждого вызова функции в списке `calls` добавляет информацию о вызывающей и вызываемой функциях в соответствующие словари в `self.call_graph`.

**Примечание**:
При использовании функции `process_file` важно убедиться, что путь к файлу (`file_path`) и язык программирования (`language`) корректно заданы и соответствуют ожидаемому формату. Некорректное использование может привести к ошибкам или неправильному извлечению информации.
***
### FunctionDef build_from_repo(self)
**build_from_repo**: Функция `build_from_repo` обходит директорию с исходными файлами проекта и вызывает функцию `process_file` для каждого найденного файла с расширением `.py`, `.go`, `.java` или `.kt`.

**parameters**:
* параметр 1: нет

**Описание кода**:
Функция `build_from_repo` выполняет обход директории `self.repo_path` с помощью функции `os.walk`. Для каждого файла в директории проверяется его расширение. В зависимости от расширения (`".py"`, `".go"`, `".java"`, `".kt"`) устанавливается соответствующий язык программирования (`"python"`, `"go"`, `"java"`, `"kotlin"`). Затем функция `process_file` вызывается для обработки файла с указанием пути к файлу и языка программирования.

Если при обработке файла возникает ошибка, сообщение об ошибке выводится на экран.

**Примечание**:
При использовании функции `build_from_repo` важно убедиться, что `repo_path` корректно задан и соответствует директории с исходными файлами проекта. Некорректное использование может привести к тому, что некоторые файлы будут пропущены или обработаны некорректно.
***
### FunctionDef get_call_graph(self)
**get_call_graph**: Функция get_call_graph возвращает граф вызовов, сохранённый в атрибуте call_graph объекта.

**Параметры**: нет параметров.

**Описание кода**: Функция get_call_graph предназначена для получения графа вызовов, который был предварительно вычислен и сохранён в атрибуте self.call_graph объекта. Она не принимает никаких входных параметров и просто возвращает текущее значение атрибута.

**Примечание**: Обратите внимание, что функция предполагает наличие предварительно рассчитанного графа вызовов в атрибуте self.call_graph. Перед использованием функции убедитесь, что граф вызовов был правильно рассчитан и сохранён.

**Пример вывода**: Нет примера вывода, так как функция просто возвращает текущее значение атрибута.
***
