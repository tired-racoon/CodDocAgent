## ClassDef TreeSitterParser
**TreeSitterParser**: Класс TreeSitterParser предназначен для парсинга кода с использованием библиотеки Tree-sitter.

**Attributes**:
* параметр 1: `repo_path` — путь к репозиторию, в котором находится файл для парсинга.
* параметр 2: `file_path` — путь к файлу, который нужно распарсить.
* `project_hierarchy` — иерархическая структура проекта, полученная из настроек.
* `language_name` — название языка программирования, определённое по расширению файла.
* `ts_language` — объект, представляющий язык программирования для использования с Tree-sitter.
* `parser` — экземпляр парсера Tree-sitter.
* `code` — код, который нужно распарсить.
* `root` — корневой узел дерева разбора.

**Описание кода**:

Класс TreeSitterParser используется для анализа и разбора файлов с использованием библиотеки Tree-sitter. В конструкторе (`__init__`) указывается путь к репозиторию и файлу для парсинга, определяется язык файла и инициализируется соответствующий парсер Tree-sitter.

Метод `_detect_language` определяет язык программирования по расширению файла. Метод `read_file` читает содержимое файла. Метод `write_file` записывает содержимое в файл. Метод `get_modified_file_versions` получает текущую и предыдущую версии файла из git.

Метод `parse_code` выполняет разбор кода с использованием парсера Tree-sitter. Метод `parse_file` читает файл и вызывает `parse_code` для его разбора. Метод `get_node_text` возвращает текстовое содержимое узла дерева разбора. Метод `extract_name` извлекает имя из узла. Метод `extract_parameters` извлекает параметры из узла функции или метода.

Метод `get_functions_and_classes` извлекает функции и классы из разобранного кода. Метод `get_obj_code_info` получает подробную информацию о коде объекта. Метод `generate_file_structure` генерирует структуру для одного файла. Метод `_fallback_file_structure` выполняет резервный разбор для неподдерживаемых типов файлов.

Метод `generate_overall_structure` генерирует структуру для всего репозитория. Метод `convert_to_markdown_file` преобразует структуру файла в формат markdown.

**Примечание**:
При использовании класса TreeSitterParser необходимо указать путь к репозиторию и файлу для парсинга. Также необходимо убедиться, что библиотека Tree-sitter установлена и доступна для использования.

**Пример вывода**:
Не применимо для данного класса.
### FunctionDef __init__(self, repo_path, file_path)
**__init__**: Функция `__init__` инициализирует объект класса `TreeSitterParser`, устанавливая начальные параметры и подготавливая среду для дальнейшего анализа файлов.

**parameters**:
- параметр 1: `repo_path` — путь к репозиторию, в котором находится анализируемый файл.
- параметр 2: `file_path` — путь к файлу, который будет анализироваться.

**Описание кода**:
Функция `__init__` выполняет несколько ключевых задач:
1. Сохраняет путь к файлу и репозиторию в соответствующие атрибуты объекта.
2. Получает настройки проекта через `SettingsManager.get_setting()` и формирует путь к иерархии проекта.
3. Определяет язык программирования файла с помощью функции `_detect_language(file_path)`.
4. На основе обнаруженного языка устанавливает соответствующий парсер `TreeSitter` (`self.parser`). Если язык не распознан, парсер устанавливается как `None`.
5. Инициализирует атрибуты `code` и `root` как `None`.

**Примечание**:
При использовании этой функции важно убедиться, что словарь `LANGUAGE_MAPPING` содержит все необходимые соответствия между расширениями файлов и языками программирования. Также необходимо учитывать корректность пути к репозиторию и файлу.
***
### FunctionDef _detect_language(self, file_path)
**_detect_language_**: Функция _detect_language определяет язык программирования по расширению файла.

**parameters**:
* параметр 1: `file_path` — путь к файлу.

**Описание кода**:
Функция _detect_language использует модуль `os` для разделения пути к файлу и получения его расширения. Затем она ищет соответствие между расширением файла и языком программирования в словаре `EXTENSION_TO_LANGUAGE`. Возвращает название языка, соответствующее найденному расширению. Функция вызывается в конструкторе `__init__` для определения языка файла и в `generate_file_structure` для определения языка перед парсингом файла.

**Примечание**:
При использовании функции важно убедиться, что словарь `EXTENSION_TO_LANGUAGE` содержит все необходимые расширения и соответствующие им языки.

**Пример вывода**:
```
_detect_language("example.py")  # Вернёт "python"
```
***
### FunctionDef read_file(self)
**read_file**: Функция read_file предназначена для чтения содержимого файла.

**parameters**:
- параметр 1: self — ссылка на экземпляр объекта, в котором вызывается метод.

**Описание кода**:
Функция read_file использует метод os.path.join для формирования абсолютного пути к файлу, который затем открывается для чтения в режиме чтения (r) с кодировкой utf-8. Содержимое файла считывается с помощью метода file.read и возвращается в качестве результата функции.

**Примечание**:
При использовании функции необходимо убедиться, что путь к файлу (self.file_path) корректно указан относительно пути к репозиторию (self.repo_path).

**Пример вывода**:
Чтение файла не демонстрирует возвращаемое значение в примере, так как оно зависит от содержимого конкретного файла.
***
### FunctionDef write_file(self, file_path, content)
**write_file**: Функция write_file предназначена для записи содержимого в файл.

**parameters**:
* параметр 1: `file_path` — путь к файлу, в который будет записано содержимое.
* параметр 2: `content` — содержимое, которое будет записано в файл.

**Описание кода**:
Функция `write_file` принимает два аргумента: `file_path` и `content`. Путь к файлу `file_path` должен быть скорректирован, если начинается с символа `/`. Затем формируется абсолютный путь к файлу с использованием `repo_path` и `file_path`. Создаются директории, необходимые для пути файла, если они ещё не существуют. После этого файл открывается в режиме записи (`"w"`) с кодировкой `utf-8`, и содержимое `content` записывается в файл.

**Примечание**:
При использовании функции `write_file` убедитесь, что путь к файлу (`file_path`) корректен и доступен для записи. Также обратите внимание на обработку путей, начинающихся с символа `/`.
***
### FunctionDef get_modified_file_versions(self)
**get_modified_file_versions**: Функция `get_modified_file_versions` получает текущую и предыдущую версии файла из системы контроля версий Git.

**parameters**:
* параметр 1: `self` — ссылка на экземпляр объекта, в котором вызывается функция;
* параметр 2: `repo_path` — путь к репозиторию Git;
* параметр 3: `file_path` — путь к файлу в репозитории.

**Описание кода**: Функция `get_modified_file_versions` выполняет следующие действия:
1. Создаёт объект `repo` типа `git.Repo` с путём к репозиторию `repo_path`.
2. Читает текущий файл в текущем рабочем каталоге (текущая версия).
3. Получает версию файла из последнего коммита (предыдущая версия).
4. Если в репозитории есть коммиты, то берёт первый коммит и пытается прочитать версию файла из его дерева.
5. Если файл не найден в предыдущих коммитах, то устанавливает `previous_version` как `None`.
6. Возвращает кортеж из текущей и предыдущей версий файла.

**Примечание**: Для корректной работы функции необходимо, чтобы путь к репозиторию и файлу были корректными. Также необходимо убедиться, что система контроля версий Git установлена и доступна в окружении.

**Пример вывода**:
```
(current_version, previous_version) = get_modified_file_versions()
```
***
### FunctionDef parse_code(self)
**parse_code**: Функция `parse_code` предназначена для разбора кода с использованием библиотеки Tree-sitter.

**parameters**:
* параметр 1: `code` — строка с исходным кодом, который нужно разобрать.

**Описание кода**: Функция `parse_code` принимает на вход строку с исходным кодом и использует экземпляр парсера Tree-sitter (`self.parser`) для его разбора. Если экземпляр парсера не был инициализирован, функция возвращает `None`. В противном случае код сохраняется в атрибут `self.code`, затем парсер разбирает его и возвращает корневой узел дерева разбора (`self.root`).

Функция `parse_code` вызывается объектом `parse_file`, который отвечает за разбор файлов в репозитории. `parse_file` открывает файл, считывает его содержимое и передаёт его в `parse_code` для дальнейшего разбора.

**Примечание**: При использовании функции `parse_code` необходимо убедиться, что экземпляр парсера `self.parser` был предварительно инициализирован. Также важно учитывать, что корректная работа функции зависит от правильной настройки и доступности библиотеки Tree-sitter.

**Пример вывода**: Функция возвращает корневой узел дерева разбора (`self.root`), который представляет собой структуру данных, отражающую синтаксическую структуру исходного кода.
***
### FunctionDef parse_file(self)
**parse_file**: Функция `parse_file` предназначена для разбора файла с использованием библиотеки Tree-sitter.

**parameters**:
* параметр 1: `filename` — строка с именем файла, который нужно разобрать.

**Описание кода**: Функция `parse_file` открывает указанный файл, считывает его содержимое и передаёт его в функцию `parse_code` для дальнейшего разбора. Для открытия файла используется путь, сформированный на основе атрибута `self.repo_path` и переданного имени файла.

Функция `parse_file` вызывается объектом `generate_file_structure`, который генерирует структуру для отдельного файла. `generate_file_structure` определяет язык файла, временно переключает язык парсера при необходимости и вызывает `parse_file` для разбора содержимого файла.

**Примечание**: При использовании функции `parse_file` необходимо убедиться, что путь к файлу указан корректно и что библиотека Tree-sitter настроена и доступна для корректной работы.

**Пример вывода**: Функция возвращает результат разбора кода с использованием функции `parse_code`, который представляет собой корневой узел дерева разбора (`self.root`).
***
### FunctionDef get_node_text(self, node)
**get_node_text**: Функция get_node_text возвращает текстовое содержимое узла.

**parameters**:
- параметр 1: node (узел, для которого нужно получить текстовое содержимое)

**Описание кода**: Функция get_node_text извлекает текстовое содержимое узла, используя его начальные и конечные байты в коде. Если код не задан, возвращается пустая строка. Функция сначала проверяет наличие кода, затем определяет начальные и конечные байты узла и извлекает текст между этими байтами.

**Примечание**: Важно убедиться, что узел, передаваемый в функцию, корректно определён и имеет установленные начальные и конечные байты.

**Пример вывода**:
```
# Пример вызова функции:
def extract_name(self, node):
    """Extract name from a node"""
    # Find the identifier child node
    for child in node.children:
        if child.type == "identifier" or child.type == "name":
            return self.get_node_text(child)
    return "<unknown>"
```
***
### FunctionDef extract_name(self, node)
**extract_name**: Функция extract_name извлекает имя из узла синтаксического дерева.

**parameters**:
* параметр 1: node (узел синтаксического дерева, из которого нужно извлечь имя)

**Описание кода**: Функция extract_name ищет в дереве дочерний узел типа "identifier" или "name" и возвращает текстовое содержимое этого узла. Если такие узлы не найдены, возвращается строка "<unknown>". Функция перебирает все дочерние узлы переданного узла и проверяет их типы. Как только находится подходящий узел, его текстовое содержимое возвращается.

**Примечание**: Важно убедиться, что узел, передаваемый в функцию, корректно определён и имеет установленные типы "identifier" или "name".

**Пример вывода**:
```
# Пример вызова функции:
def extract_name(self, node):
    """Extract name from a node"""
    # Find the identifier child node
    for child in node.children:
        if child.type == "identifier" or child.type == "name":
            return self.get_node_text(child)
    return "<unknown>"
```
***
### FunctionDef extract_parameters(self, node)
**extract_parameters**: Функция `extract_parameters` извлекает параметры функций или методов на основе заданного языка программирования.

**parameters**:
* параметр 1: `node` (узел, для которого нужно извлечь параметры)

**Описание кода**: Функция `extract_parameters` определяет язык программирования (`self.language_name`) и вызывает соответствующую функцию для извлечения параметров. В зависимости от языка (`python`, `java`, `go`, `kotlin`) вызываются функции `_extract_python_parameters`, `_extract_java_parameters`, `_extract_go_parameters` или `_extract_kotlin_parameters` соответственно. Если язык не распознан, возвращается пустой список.

Функция `extract_parameters` используется в контексте обхода дерева синтаксического анализа для извлечения функций и классов. Она вызывается в функции `get_functions_and_classes`, которая рекурсивно обходит дерево и извлекает определения функций и классов.

**Примечание**: Важно убедиться, что узел `node` корректно определён и содержит необходимые дочерние узлы для корректной работы функции. Также необходимо учитывать специфику каждого языка при извлечении параметров.

**Пример вывода**:
Вызов функции `extract_parameters` позволяет извлечь параметры функции или метода на основе заданного языка программирования. Например, если узел содержит параметры функции на языке Python, функция вернёт список имён параметров. Если параметры не найдены или язык не распознан, функция вернёт пустой список.
***
### FunctionDef _extract_python_parameters(self, node)
**_extract_python_parameters**: Функция _extract_python_parameters извлекает параметры для функций на языке Python.

**parameters**:
- параметр 1: `node` (узел, для которого нужно извлечь параметры)

**Описание кода**: Функция _extract_python_parameters проходит по дочерним узлам переданного узла `node` и извлекает параметры функции. Она ищет дочерние узлы типа "parameters" и "identifier" или "default_parameter". Для каждого найденного параметра типа "identifier" или "default_parameter" (для получения имени параметра из узла "default_parameter" дополнительно ищется дочерний узел типа "identifier") добавляется текст узла в список `params`. После завершения цикла возвращается список `params` с извлечёнными параметрами. Если подходящих узлов не найдено, возвращается пустой список.

Функция вызывается из `extract_parameters`, которая определяет язык и вызывает соответствующую функцию для извлечения параметров в зависимости от языка.

**Примечание**: Важно убедиться, что узел `node` корректно определён и содержит необходимые дочерние узлы для корректной работы функции.

**Пример вывода**:
```
# Пример вызова функции:
def extract_parameters(self, node):
    """Extract parameters from function/method node"""
    if self.language_name == "python":
        return self._extract_python_parameters(node)
    elif self.language_name == "java":
        return self._extract_java_parameters(node)
    elif self.language_name == "go":
        return self._extract_go_parameters(node)
    elif self.language_name == "kotlin":
        return self._extract_kotlin_parameters(node)
    return []
```
***
### FunctionDef _extract_java_parameters(self, node)
**_extract_java_parameters**: Функция _extract_java_parameters извлекает параметры для методов Java.

**parameters**:
- параметр 1: node (узел, для которого нужно извлечь параметры)

**Описание кода**: Функция _extract_java_parameters проходит по дочерним узлам переданного узла и ищет узел с типом "formal_parameters". Затем она извлекает все дочерние узлы с типом "formal_parameter" и для каждого из них находит последний идентификатор (имя параметра). Найденные имена параметров добавляются в список params. Если в узле "formal_parameter" нет идентификаторов, возвращается пустой список.

Функция использует метод get_node_text для получения текстового содержимого узла. Этот метод извлекает текст между начальными и конечными байтами узла из общего кода.

**Примечание**: Важно убедиться, что узел node корректно определён и имеет установленные начальные и конечные байты.

**Пример вызова**: функция _extract_java_parameters вызывается из функции extract_parameters, которая определяет язык программирования и вызывает соответствующую функцию для извлечения параметров.
***
### FunctionDef _extract_go_parameters(self, node)
**_extract_go_parameters**: Функция _extract_go_parameters извлекает параметры для функций на языке Go.

**parameters**:
- параметр 1: node (узел, для которого нужно извлечь параметры)

**Описание кода**: Функция _extract_go_parameters проходит по дочерним узлам переданного узла и ищет список параметров. Затем она извлекает имена параметров, перебирая дочерние узлы списка параметров и находя среди них идентификаторы.

Функция начинается с перебора всех дочерних узлов узла `node`. Если встречается узел типа `parameter_list`, то для каждого параметра в этом списке формируется список `params`. Далее функция перебирает дочерние узлы узла `parameter_declaration` и ищет среди них идентификаторы, чтобы добавить их имена в список `params`. В конце возвращается список `params` или пустой список, если параметры не найдены.

Функция _extract_go_parameters вызывается из функции `extract_parameters`, которая в зависимости от языка программирования вызывает соответствующие функции для извлечения параметров.

**Примечание**: Важно убедиться, что узел `node` корректно определён и содержит список параметров.

**Пример вывода**:
Вызов функции может выглядеть следующим образом:
```
def extract_parameters(self, node):
    """Extract parameters from function/method node"""
    if self.language_name == "go":
        return self._extract_go_parameters(node)
    return []
```
***
### FunctionDef _extract_kotlin_parameters(self, node)
**_extract_kotlin_parameters**: Функция _extract_kotlin_parameters извлекает параметры для функций Kotlin.

**parameters**:
- параметр 1: node (узел, для которого нужно извлечь параметры)

**Описание кода**: Функция _extract_kotlin_parameters обходит дерево синтаксического анализа, чтобы найти узел с параметрами функции. Для каждого узла она проверяет, есть ли у него дочерние элементы типа "function_value_parameters". Затем она извлекает параметры функции, обходя дочерние элементы типа "function_value_parameter" и находя имена параметров среди дочерних элементов типа "simple_identifier".

Функция использует метод get_node_text для получения текстового содержимого каждого параметра. Если имя параметра найдено, оно добавляется в список params. В конце функция возвращает список params, содержащий все найденные имена параметров, или пустой список, если параметры не найдены.

Эта функция вызывается из функции extract_parameters, которая выбирает соответствующую функцию для извлечения параметров в зависимости от языка программирования.

**Примечание**: Важно убедиться, что узел, передаваемый в функцию, корректно определён и имеет установленные начальные и конечные байты. Также необходимо проверить, что дочерние элементы узла имеют ожидаемые типы.

**Пример вывода**:
Вызов функции _extract_kotlin_parameters позволяет извлечь параметры функции Kotlin из узла синтаксического анализа. Например, если узел содержит параметры функции, функция вернёт список имён параметров. Если параметры не найдены, функция вернёт пустой список.
***
### FunctionDef get_functions_and_classes(self)
**get_functions_and_classes**: Функция `get_functions_and_classes` извлекает функции и классы из проанализированного кода.

**parameters**:
* параметр 1: `self` (ссылка на экземпляр объекта `TreeSitterParser`)

**Описание кода**: Функция `get_functions_and_classes` обходит дерево синтаксического анализа и извлекает определения функций и классов. Она использует рекурсивный обход дерева с помощью вспомогательной функции `walk`.

Функция `get_functions_and_classes` сначала проверяет, что корневой узел (`self.root`) и язык программирования (`self.language_name`) определены. Затем она вызывает функцию `walk` для обхода дерева.

Функция `walk` рекурсивно обходит все дочерние узлы узла `node`. Для каждого узла она проверяет его тип (`node_type`) и, если это функция или класс, извлекает соответствующее имя, параметры и текстовое содержимое. Извлечённые данные добавляются в список `result`.

Если узел не является функцией или классом, функция `walk` вызывает себя для обхода его дочерних узлов.

После завершения обхода дерева функция `get_functions_and_classes` возвращает список `result`, содержащий кортежи с информацией о функциях и классах.

**Примечание**: Важно убедиться, что корневой узел (`self.root`) и язык программирования (`self.language_name`) определены перед вызовом функции `get_functions_and_classes`. Также необходимо учитывать специфику каждого языка при извлечении функций и классов.

**Пример вывода**:
Функция `get_functions_and_classes` возвращает список кортежей, каждый из которых содержит информацию о функции или классе. Например, кортеж может содержать следующие элементы: тип (`FunctionDef` или `ClassDef`), имя, начальную и конечную строки, параметры, родительский элемент и текстовое содержимое.
***
### FunctionDef get_obj_code_info(self, code_type, code_name, start_line, end_line, params, file_path)
**get_obj_code_info**: Функция get_obj_code_info получает подробную информацию о коде объекта.

**parameters**:
* параметр 1: code_type (тип кода)
* параметр 2: code_name (имя кода)
* параметр 3: start_line (начальная строка кода)
* параметр 4: end_line (конечная строка кода)
* параметр 5: params (параметры кода)
* параметр 6: file_path (путь к файлу, опционально)

**Описание кода**:
Функция get_obj_code_info используется для получения подробной информации о коде объекта, включая его тип, имя, параметры и содержимое. Она также определяет, есть ли в коде оператор return и позицию имени объекта в коде.

Функция принимает следующие параметры:
* code_type — тип кода объекта;
* code_name — имя кода объекта;
* start_line — начальная строка кода объекта;
* end_line — конечная строка кода объекта;
* params — параметры кода объекта;
* file_path — путь к файлу, в котором находится код (опционально).

Если file_path не указан, используется значение self.file_path.

Функция открывает файл, указанный в parameter file_path, если он был передан, или self.file_path, если file_path не был передан. Затем она считывает содержимое файла и определяет начальную и конечную строки кода объекта.

Функция также проверяет наличие оператора return в коде и сохраняет эту информацию в словаре code_info.

Функция возвращает словарь code_info, содержащий следующую информацию:
* type — тип кода;
* name — имя кода;
* md_content — содержимое кода в формате Markdown;
* code_start_line — начальная строка кода;
* code_end_line — конечная строка кода;
* params — параметры кода;
* have_return — наличие оператора return;
* code_content — содержимое кода;
* name_column — позиция имени кода в строке.

Функция get_obj_code_info используется в контексте анализа структуры файла и получения информации о функциях и классах в файле.

**Примечание**:
При использовании функции get_obj_code_info необходимо убедиться, что параметры start_line и end_line соответствуют действительным строкам в файле. В противном случае функция может вернуть некорректные результаты.
***
### FunctionDef generate_file_structure(self, file_path)
**generate_file_structure**: Функция `generate_file_structure` предназначена для генерации структуры отдельного файла.

**parameters**:
* параметр 1: `file_path` — путь к файлу, для которого нужно сгенерировать структуру.

**Описание кода**: Функция `generate_file_structure` сначала определяет язык программирования файла с помощью функции `_detect_language`. Если язык не поддерживается или не определён, функция возвращает структуру файла, созданную с помощью `_fallback_file_structure`.

В случае поддержки языка функция временно изменяет текущий язык парсера на соответствующий языку файла и выполняет разбор файла с помощью `parse_file`. Затем функция извлекает информацию о функциях и классах из дерева разбора с помощью `get_functions_and_classes`.

Для каждой функции или класса формируется словарь с информацией о типе, имени, начальной и конечной строках, параметрах, родительском элементе и содержимом кода. Эти словари добавляются в список `file_objects`, который затем возвращается в качестве результата.

После завершения работы с файлом язык парсера и другие настройки восстанавливаются до исходных значений.

**Примечание**: При использовании функции `generate_file_structure` необходимо убедиться, что путь к файлу указан корректно, и что словарь `EXTENSION_TO_LANGUAGE` содержит все необходимые расширения и соответствующие им языки. Также важно учитывать специфику каждого языка при извлечении функций и классов.

**Пример вывода**: Функция возвращает список словарей, каждый из которых содержит информацию о функции или классе в файле.
***
### FunctionDef _fallback_file_structure(self, file_path)
**_fallback_file_structure**: Функция _fallback_file_structure используется для обработки файлов с неподдерживаемыми типами.

**parameters**:
- параметр 1: `file_path` — путь к файлу, который нужно обработать.

**Описание кода**:
Функция _fallback_file_structure вызывается, когда не удаётся определить язык файла или язык не поддерживается. В этом случае возвращается пустая структура. Это позволяет избежать ошибок при обработке файлов с неизвестными форматами.

Функция _fallback_file_structure используется в методе `generate_file_structure` для обработки файлов, для которых не удалось определить язык. Если язык файла не найден или не поддерживается, то вызывается _fallback_file_structure, которая возвращает пустую структуру. Это позволяет продолжить обработку файла, но без анализа его содержимого.

**Примечание**:
При использовании функции _fallback_file_structure важно учитывать, что она возвращает пустую структуру для файлов с неподдерживаемыми типами. Это может повлиять на дальнейшую обработку файла в системе.

**Пример вывода**:
```
[]
```
***
### FunctionDef generate_overall_structure(self, file_path_reflections, jump_files)
**generate_overall_structure**: Функция `generate_overall_structure` генерирует структуру для всего репозитория.

**parameters**:
* параметр 1: `file_path_reflections` — список отражений путей к файлам, которые нужно учесть при построении структуры репозитория;
* параметр 2: `jump_files` — список файлов, которые следует игнорировать при построении структуры репозитория.

**Описание кода**: Функция `generate_overall_structure` проходит по всем файлам в репозитории, проверяет их на соответствие правилам игнорирования (согласно файлу .gitignore) и генерирует структуру для каждого файла, который не был проигнорирован. Для этого используется вспомогательная функция `generate_file_structure`. Затем результаты объединяются в общий словарь `repo_structure`, который и возвращается в качестве результата.

При обходе файлов используется индикатор прогресса `tqdm` для отображения хода выполнения. Если файл был проигнорирован или возникла ошибка при генерации его структуры, об этом выводится соответствующее сообщение в консоль.

**Примечание**: При использовании функции `generate_overall_structure` необходимо убедиться, что список `file_path_reflections` содержит корректные пути к файлам репозитория, а список `jump_files` — корректные пути к файлам, которые нужно игнорировать. Также важно учесть, что функция `generate_file_structure` может возвращать ошибку, если файл не поддерживается или не может быть обработан. В этом случае в лог будет записано соответствующее сообщение.

**Пример вывода**: Функция возвращает словарь `repo_structure`, где ключами являются имена файлов, а значениями — структуры файлов, сгенерированные функцией `generate_file_structure`.
***
### FunctionDef convert_to_markdown_file(self, file_path)
**convert_to_markdown_file**: Функция convert_to_markdown_file преобразует структуру файла в формат Markdown.

**parameters**:
* параметр 1: `file_path` (по умолчанию равен `self.file_path`) — путь к файлу, структура которого будет преобразована в формат Markdown.

**Описание кода**:
Функция `convert_to_markdown_file` считывает структуру проекта из файла `project_hierarchy.json` и преобразует её в формат Markdown. Она обрабатывает как список, так и словарь объектов файлов и выводит их в формате Markdown.

Функция начинает с открытия файла `project_hierarchy.json` в режиме чтения с кодировкой `utf-8`. Затем она считывает данные в формате JSON. Если путь к файлу не указан, используется значение `self.file_path`.

Далее функция проверяет тип данных `json_data.get(file_path)`. Если это список, она преобразует его в словарь, где ключами являются имена объектов файлов. Если это уже словарь, функция просто получает его.

Затем функция сортирует объекты файлов по номеру строки начала кода и создаёт словарь `parent_dict`, где ключами являются имена объектов, а значениями — имена их родительских объектов.

После этого функция проходит по всем объектам файлов и выводит их в формате Markdown. Для каждого объекта она определяет уровень вложенности и выводит соответствующий заголовок. Если объект является функцией, она выводит её имя и параметры в формате `FunctionDef {name}({params})`.

**Примечание**:
Обратите внимание, что функция предполагает наличие определённых ключей в данных JSON, таких как `name`, `code_start_line`, `type` и `params`. Если эти ключи отсутствуют или имеют неправильные значения, функция может выдать ошибку или некорректный результат.

**Пример вывода**:
Пример вывода функции зависит от структуры данных в `project_hierarchy.json` и может включать заголовки разного уровня, имена функций и их параметры в формате Markdown.
***
