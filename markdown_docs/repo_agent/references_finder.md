## ClassDef ReferenceObject
**ReferenceObject**: Функция ReferenceObject имитирует справочный объект Jedi с атрибутами name, line, column и module_path.

**Attributes**:
* параметр 1: name (str) — имя объекта;
* параметр 2: line (int) — номер строки;
* параметр 3: column (int) — номер столбца;
* параметр 4: module_path (str) — путь к модулю.

**Описание кода**:

Класс ReferenceObject предназначен для имитации справочных объектов Jedi. Он создаётся с указанием имени, номера строки, номера столбца и пути к модулю. Метод __repr__ возвращает строковое представление объекта в формате "<ReferenceObject: {name} at {module_path}:{line}:{column}>".

Этот класс используется в методе get_references класса ReferenceFinder для создания экземпляров ReferenceObject на основе найденных ссылок. Метод get_references принимает параметры line и column, которые определяют позицию курсора в файле, и параметр scope, который определяет область поиска (файл или проект).

Метод get_references сначала проверяет наличие пути к файлу и существования файла. Затем он определяет язык файла и использует соответствующий парсер для анализа файла. После этого метод находит идентификатор в указанной позиции и использует его для поиска ссылок. Найденные ссылки преобразуются в экземпляры ReferenceObject и возвращаются в виде списка.

**Примечание**:
При использовании класса ReferenceObject необходимо убедиться, что все параметры (name, line, column, module_path) заданы корректно. Также необходимо учитывать, что метод get_references может возвращать пустой список, если ссылки не найдены или возникли ошибки при анализе файла.

**Пример вывода**:
```
<ReferenceObject: {name} at {module_path}:{line}:{column}>
```
### FunctionDef __init__(self)
**__init__**: Функция __init__ используется для инициализации объекта класса ReferenceObject, задавая его основные атрибуты.

**parameters**:
- параметр 1: `name: str` — имя, которое будет присвоено объекту.
- параметр 2: `line: int` — номер строки в файле, где был найден объект.
- параметр 3: `column: int` — номер колонки в строке, где был найден объект.
- параметр 4: `module_path: str` — путь к модулю, в котором был найден объект.

**Описание кода**:
Функция __init__ принимает четыре параметра и присваивает их значения соответствующим атрибутам объекта. Это позволяет создать экземпляр класса ReferenceObject с заданными характеристиками. При создании нового объекта класса ReferenceObject, разработчик должен указать его имя, номер строки и колонки, где он был найден, а также путь к модулю. Эти данные сохраняются в атрибутах объекта для последующего использования.

**Примечание**:
При использовании функции __init__ важно убедиться, что все переданные параметры являются корректными и соответствуют ожидаемому типу данных. Некорректные значения могут привести к ошибкам в работе программы.
***
### FunctionDef __repr__(self)
**__repr__**: Функция `__repr__` имеет значение возврата строкового представления объекта `ReferenceObject`.

**parameters**: нет параметров.

**Описание кода**: функция `__repr__` возвращает строковое представление объекта `ReferenceObject`, включая его имя, путь к модулю, номер строки и номер столбца, где он был определён. Это позволяет легко идентифицировать объект при выводе его на экран или в лог-файл.

**Примечание**: при использовании функции `__repr__` можно получить полное представление объекта `ReferenceObject`, что может быть полезно для отладки и логирования.

**Пример вывода**: `<ReferenceObject: {name} at {module_path}:{line}:{column}>`
***
## ClassDef ReferenceFinder
**ReferenceFinder**: класс ReferenceFinder предназначен для поиска ссылок на переменные в исходном коде, написанном на различных языках программирования.

**attributes**:
* параметр 1: `repo_path` (str) — путь к репозиторию.
* параметр 2: `file_path` (str) — путь к файлу, в котором производится поиск (по умолчанию пустой).
* `parsers` (dict) — словарь, кэширующий парсеры для разных языков.
* `identifier_types` (dict) — словарь, содержащий типы идентификаторов для каждого языка.
* `scope_types` (dict) — словарь, содержащий типы областей видимости для каждого языка.
* `import_patterns` (dict) — словарь, содержащий шаблоны импорта для каждого языка.
* `definition_types` (dict) — словарь, содержащий типы определений для каждого языка.

**Описание кода**:

Класс ReferenceFinder предназначен для поиска ссылок на переменные в исходном коде. Он поддерживает несколько языков программирования, включая Python, Java, Go и Kotlin. Для каждого языка класс хранит информацию о типах идентификаторов, областях видимости, шаблонах импорта и типах определений.

Класс использует библиотеку TreeSitter для синтаксического анализа исходного кода. Для каждого языка класс создаёт экземпляр парсера TreeSitter, который используется для анализа кода.

Метод `_get_parser` возвращает экземпляр парсера для заданного языка. Метод `_get_extension` возвращает расширение файла для заданного языка. Метод `_detect_language` определяет язык файла по его расширению.

Метод `_find_node_at_position` находит узел синтаксического дерева, соответствующий заданной позиции в файле. Метод `_get_identifier_at_position` возвращает имя идентификатора в заданной позиции. Метод `_find_all_identifiers` находит все вхождения идентификатора в синтаксическом дереве.

Метод `_get_reference_context` определяет контекст ссылки (определение, использование и т. д.). Метод `_filter_references_by_scope` фильтрует ссылки на основе области видимости. Метод `_filter_references_by_imports` фильтрует ссылки на основе анализа импорта.

Метод `find_references_in_file` находит все ссылки на переменную в заданном файле. Метод `find_references_in_repo` находит все ссылки на переменную во всём репозитории. Метод `get_references` возвращает список объектов ReferenceObject, представляющих ссылки на переменную.

**Примечание**:

При использовании класса ReferenceFinder необходимо указать путь к репозиторию и путь к файлу, в котором производится поиск. Метод `find_references_in_file` возвращает список ссылок на переменную в заданном файле, а метод `find_references_in_repo` возвращает список ссылок на переменную во всём репозитории.

**Пример использования**:

```python
from repo_agent.references_finder import ReferenceFinder

repo_path = '/path/to/repo'
file_path = 'path/to/file.py'
variable_name = 'my_var'

finder = ReferenceFinder(repo_path, file_path)
references = finder.get_references(line_number, column_number, scope)
```
### FunctionDef __init__(self)
**__init__**: Функция `__init__` инициализирует объект класса `ReferenceFinder` и задаёт начальные параметры для работы с репозиторием и файлами.

**parameters**:
* `repo_path: str` — путь к репозиторию.
* `file_path: str = ''` — путь к файлу в репозитории (по умолчанию пустая строка).

**Описание кода**:
Функция `__init__` выполняет несколько ключевых задач:
* Инициализирует атрибут `repo_path` путём присвоения ему значения первого параметра `repo_path`.
* Инициализирует атрибут `file_path` путём присвоения ему значения второго параметра `file_path`. Этот атрибут хранит путь к текущему файлу.
* Создаёт пустой словарь `self.parsers`, который будет использоваться для кэширования парсеров для разных языков.
* Инициализирует словари `self.identifier_types`, `self.scope_types`, `self.import_patterns` и `self.definition_types`, содержащие типы идентификаторов, области видимости, шаблоны импорта и типы определений для различных языков программирования (Python, Java, Go, Kotlin).

**Примечание**:
При использовании `file_path` по умолчанию как пустой строки, предполагается, что основной анализ будет проводиться на уровне репозитория, а не конкретного файла. Это важно учитывать при настройке параметров для работы с кодом.
***
### FunctionDef _get_parser(self)
**_get_parser_**: Функция _get_parser получает или создаёт парсер для определённого языка программирования.

**parameters**:
* параметр 1: **language** — строка, указывающая на язык программирования.

**Описание кода**:
Функция _get_parser проверяет, есть ли в словаре self.parsers ключ, соответствующий указанному языку программирования. Если такого ключа нет, она создаёт новый экземпляр парсера TreeSitterParser с использованием пути к репозиторию и фиктивного пути файла с расширением, соответствующим данному языку, и добавляет его в словарь self.parsers. Затем функция возвращает созданный или уже существующий парсер для указанного языка.

Эта функция используется в контексте работы с различными языками программирования и их парсерами. Она обеспечивает создание и получение парсеров для разных языков, что необходимо для анализа кода.

**Примечание**:
При использовании функции _get_parser важно убедиться, что передаваемый параметр language соответствует одному из ключей в словаре self.parsers. В противном случае будет создан и возвращён парсер с некорректными настройками, что может привести к ошибкам при анализе кода.
***
### FunctionDef _get_extension(self)
**_get_extension**: Функция _get_extension возвращает расширение файла для заданного языка программирования.

**parameters**:
* параметр 1: language — строка, указывающая на язык программирования.

**Описание кода**:
Функция _get_extension принимает на вход строку language, которая представляет собой название языка программирования. Затем она обращается к словарю extensions, где каждому языку соответствует определённое расширение файла. Если указанный язык присутствует в словаре, возвращается соответствующее ему расширение. В противном случае возвращается значение «txt».

Функция используется в контексте работы с парсерами для различных языков программирования. Она помогает определить правильное расширение файла, которое будет использоваться при создании парсера для конкретного языка.

**Примечание**:
При использовании функции _get_extension важно убедиться, что передаваемый параметр language соответствует одному из ключей в словаре extensions. В противном случае функция вернёт значение по умолчанию «txt», что может привести к некорректной работе парсера.

**Пример вывода**:
_get_extension("python") вернёт "py"
***
### FunctionDef _detect_language(self)
**_detect_language**: Функция _detect_language определяет язык программирования файла на основе его расширения.

**parameters**:
* параметр 1: `file_path` — путь к файлу.

**Описание кода**:
Функция _detect_language принимает путь к файлу и возвращает язык программирования, соответствующий расширению файла. В словаре `ext_to_lang` задаются соответствия между расширениями файлов и языками программирования. Затем функция разделяет путь и расширение файла с помощью `os.path.splitext` и получает расширение файла в нижнем регистре. После этого функция пытается найти соответствие между полученным расширением и языком в словаре `ext_to_lang`. Если соответствие найдено, возвращается соответствующий язык, иначе возвращается `None`.

Функция _detect_language вызывается в следующих ситуациях:
* В функции `find_references_in_file` для определения языка файла перед парсингом и поиском ссылок на переменную.
* В функции `_filter_references_by_imports` для определения языка файла перед анализом импортов.
* В функции `find_references_in_repo` для определения языка файла перед поиском ссылок на переменную в репозитории.
* В функции `get_references` для определения языка файла перед поиском ссылок на переменную.

**Примечание**:
При использовании функции _detect_language важно убедиться, что путь к файлу указан корректно и что расширение файла соответствует заданному в словаре `ext_to_lang`. В противном случае функция может вернуть `None`, что приведёт к ошибкам в работе других функций.
***
### FunctionDef _get_node_text(self)
**_get_node_text_**: Функция _get_node_text извлекает текст из узла дерева Tree-sitter.

**parameters**:
* параметр 1: `node: Node` — узел дерева Tree-sitter, из которого нужно извлечь текст.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.

**Описание кода**:
Функция _get_node_text принимает узел дерева Tree-sitter и байтовую последовательность кода. Если узел не существует, возвращается пустая строка. В противном случае возвращается подстрока из `code`, начиная с `node.start_byte` и заканчивая `node.end_byte`, декодированная в строку UTF-8 с игнорированием ошибок.

Функция используется в следующих ситуациях:
* В функции `_get_identifier_at_position` для извлечения имени идентификатора по заданной позиции.
* В функции `_find_all_identifiers` для поиска всех вхождений идентификатора в синтаксическом дереве.
* В функции `_extract_imports` для извлечения всех импортов из файла.
* В функции `_find_function_context` для поиска контекста функции.
* В функциях `_check_python_local_definition`, `_check_java_local_definition`, `_check_go_local_definition` и `_check_kotlin_local_definition` для проверки локального определения идентификатора.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности `code`. Убедитесь, что `code` правильно декодируется в UTF-8.
***
### FunctionDef _find_node_at_position(self)
**_find_node_at_position_**: Функция _find_node_at_position находит наиболее конкретный узел в дереве синтаксического анализа (Node) по заданным строке и столбцу.

**parameters**:
- параметр 1: **root** (Node) — корневой узел дерева синтаксического анализа.
- параметр 2: **line** (int) — номер строки (на основе 1).
- параметр 3: **column** (int) — номер столбца (на основе 0).

**Описание кода**:
Функция _find_node_at_position использует вспомогательную функцию find_deepest для поиска узла, соответствующего заданной позиции. Сначала она преобразует номер строки в систему отсчёта от 0, используемую в Tree-sitter. Затем проверяет, находится ли позиция в пределах границ текущего узла. Если да, то функция ищет более глубокие соответствия в дочерних узлах. Если находит, возвращает этот узел. Если нет, продолжает поиск в родительских узлах. Если достигает корневого узла и не находит соответствия, возвращает None.

Функция вызывается в нескольких местах для поиска узлов, соответствующих заданным позициям, и определения идентификаторов и контекста функций. Например, в _get_identifier_at_position она используется для поиска узла, содержащего идентификатор в заданной позиции, а в _find_function_context — для поиска контекста функции по заданной позиции.

**Примечание**:
При использовании функции _find_node_at_position важно учитывать, что она возвращает наиболее конкретный узел, соответствующий заданной позиции. Это может быть полезно при поиске идентификаторов, функций и других элементов кода. Однако, если требуется найти все узлы, соответствующие заданной позиции, необходимо использовать дополнительные проверки.
***
### FunctionDef _get_identifier_at_position(self)
**_get_identifier_at_position_**: Функция _get_identifier_at_position получает имя идентификатора в заданной позиции в исходном коде.

**parameters**:
* параметр 1: `root: Node` — корневой узел дерева синтаксического анализа.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `language: str` — язык программирования, используемый в коде.
* параметр 4: `line: int` — номер строки (на основе 1), в которой находится идентификатор.
* параметр 5: `column: int` — номер столбца (на основе 0), в котором находится идентификатор.

**Описание кода**:
Функция _get_identifier_at_position ищет узел в дереве синтаксического анализа, который соответствует заданной позиции. Если такой узел найден, функция проверяет, является ли он идентификатором. Если да, то возвращается текст узла. Если нет, функция ищет идентификатор в родительских узлах или в дочерних узлах узла. Если идентификатор не найден, возвращается `None`.

Функция используется в методе `get_references` для поиска идентификатора в заданной позиции и определения его имени. Это позволяет найти все ссылки на идентификатор в файле или в проекте.

**Примечание**:
При использовании функции _get_identifier_at_position важно учитывать, что она возвращает имя идентификатора, если он найден. Если идентификатор не найден, возвращается `None`. Убедитесь, что параметры `line` и `column` соответствуют структуре исходного кода.
***
### FunctionDef _find_all_identifiers(self)
**_find_all_identifiers_**: Функция _find_all_identifiers находит все вхождения идентификатора в синтаксическом дереве.

**parameters**:
* параметр 1: `root: Node` — корень синтаксического дерева, полученного от парсера Tree-sitter.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `language: str` — язык программирования, используемый в коде.
* параметр 4: `target_name: str` — имя идентификатора, которое нужно найти.

**Описание кода**: функция _find_all_identifiers обходит синтаксическое дерево и находит все узлы, которые соответствуют типу идентификаторов для заданного языка программирования. Для каждого такого узла она извлекает текст и проверяет, совпадает ли он с искомым идентификатором. Если да, то функция добавляет в список кортежей информацию о позиции узла в коде (номер строки и столбца) и контексте ссылки (определение, использование и т. д.).

Функция использует вспомогательные функции _get_node_text и _get_reference_context для извлечения текста узла и определения контекста ссылки. Функция _find_all_identifiers вызывается из функции find_references_in_file для поиска всех ссылок на переменную в файле.

**Примечание**: при использовании функции _find_all_identifiers важно убедиться, что параметры root, code, language и target_name являются корректными. Код должен быть правильно декодирован в UTF-8.

**Пример вывода**:
функция возвращает список кортежей, каждый из которых содержит номер строки, номер столбца и контекст ссылки для каждого вхождения идентификатора.
***
### FunctionDef _get_reference_context(self)
**_get_reference_context_**: Функция _get_reference_context определяет контекст ссылки (определение, использование и т. д.) на основе типа узла и его родителей.

**parameters**:
- параметр 1: node (Node) — текущий узел, для которого определяется контекст ссылки;
- параметр 2: language (str) — язык программирования, используемый в коде.

**Описание кода**: функция _get_reference_context анализирует структуру синтаксического дерева и определяет, является ли узел частью определения или его использование. Если узел не имеет родителя, функция возвращает «usage». В противном случае она проходит вверх по дереву, проверяя типы узлов. Если тип узла соответствует определённым критериям (например, assignment для Python или variable_declarator для Java), функция возвращает «definition».

Функция _get_reference_context вызывается в процессе поиска всех идентификаторов в синтаксическом дереве. Она помогает определить контекст каждого вхождения идентификатора.

Если язык программирования — Python, функция проверяет наличие назначений и определений функций или классов. Для Java она ищет объявления переменных.

**Примечание**: при использовании функции _get_reference_context важно убедиться, что переданные параметры являются корректными узлами (Node) и что язык программирования указан правильно.

**Пример вывода**:
_get_reference_context(node, language) -> "definition" или "usage"
***
### FunctionDef _node_contains_position(self)
**_node_contains_position_**: Функция _node_contains_position проверяет, содержит ли узел-контейнер target узел.

**parameters**:
* параметр 1: container (Node)
* параметр 2: target (Node)

**Описание кода**: Функция _node_contains_position принимает два параметра: container и target, которые являются узлами (Node). Если любой из параметров отсутствует, функция возвращает False. Внутри функции используется вложенная функция check_children, которая рекурсивно проверяет, содержит ли текущий узел target. Если target найден в любом из дочерних узлов container, функция возвращает True. В противном случае возвращается False.

Функция _node_contains_position вызывается в функции _get_reference_context, которая определяет контекст ссылки (определение, использование и т. д.) в зависимости от типа узла и его родителей. Если узел является частью определения (например, в случае с определениями функций или классов в Python), функция возвращает "definition". В противном случае возвращается "usage".

**Примечание**: При использовании функции _node_contains_position важно убедиться, что переданные параметры являются корректными узлами (Node).

**Пример вывода**:
```
_node_contains_position(container, target) -> True/False
```
***
### FunctionDef _is_same_scope(self)
**_is_same_scope**: Функция _is_same_scope проверяет, находятся ли две позиции в одной области видимости (scope) в исходном коде.

**parameters**:
- параметр 1: **root** (Node) — корневой узел дерева синтаксического анализа.
- параметр 2: **language** (str) — язык программирования, для которого выполняется проверка области видимости.
- параметр 3: **pos1** (Tuple[int, int]) — первая позиция (строка, столбец) для проверки.
- параметр 4: **pos2** (Tuple[int, int]) — вторая позиция (строка, столбец) для проверки.

**Описание кода**:
Функция _is_same_scope сначала получает множество типов узлов, которые определяют области видимости для заданного языка. Затем она использует вспомогательную функцию find_enclosing_scope для поиска узла, который охватывает каждую из заданных позиций. После этого функция сравнивает найденные узлы и возвращает True, если они совпадают (то есть позиции находятся в одной области видимости), и False в противном случае.

Функция find_enclosing_scope начинает с поиска узла в дереве синтаксического анализа, который соответствует заданной позиции. Затем она движется вверх по иерархии узлов, пока не найдёт узел, который определяет область видимости. Если такого узла не находится, возвращается корневой узел, что означает глобальную область видимости.

Функция _is_same_scope вызывается в контексте фильтрации ссылок на основе правил области видимости. Например, в функции _filter_references_by_scope она используется для определения, находятся ли ссылки в той же области видимости, что и определения, чтобы правильно фильтровать их.

**Примечание**:
При использовании функции _is_same_scope важно учитывать, что она зависит от корректного определения типов узлов, которые определяют области видимости для заданного языка. Это обеспечивает правильное определение областей видимости и корректную работу функции.
***
### FunctionDef _filter_references_by_scope(self)
**_filter_references_by_scope**: Функция _filter_references_by_scope фильтрует ссылки на основе правил области видимости.

**parameters**:
* параметр 1: **references** (List[Tuple[int, int, str]]) — список ссылок в формате (строка, столбец, контекст).
* параметр 2: **origin_pos** (Tuple[int, int]) — начальная позиция (строка, столбец) для проверки области видимости.
* параметр 3: **root** (Node) — корневой узел дерева синтаксического анализа.
* параметр 4: **language** (str) — язык программирования, для которого выполняется проверка области видимости.

**Описание кода**:
Функция _filter_references_by_scope перебирает список ссылок и проверяет, находятся ли они в той же области видимости, что и определения. Для этого используется вспомогательная функция _is_same_scope. Ссылки, которые находятся в правильной области видимости, добавляются в новый список. Функция возвращает отфильтрованный список ссылок.

Ссылки всегда включаются, если их контекст — «definition». Для использования проверяется, находятся ли они в той же области видимости, что и определение. Проверка упрощена и требует полноценного анализа области видимости.

Функция вызывается в контексте фильтрации ссылок на основе правил области видимости. Она используется для определения, находятся ли ссылки в той же области видимости, что и определения, чтобы правильно фильтровать их.

**Примечание**:
При использовании функции _filter_references_by_scope важно учитывать, что она зависит от корректной работы функции _is_same_scope, которая, в свою очередь, зависит от корректного определения типов узлов, которые определяют области видимости для заданного языка. Это обеспечивает правильное определение областей видимости и корректную работу функции.
***
### FunctionDef find_references_in_file(self)
**find_references_in_file**: Функция find_references_in_file находит все ссылки на переменную в указанном файле.

**parameters**:
* параметр 1: `file_path: str` — путь к файлу, в котором нужно найти ссылки.
* параметр 2: `variable_name: str` — имя переменной, ссылки на которую нужно найти.
* параметр 3: `origin_line: int` — номер строки, где находится исходная позиция переменной.
* параметр 4: `origin_column: int` — номер столбца, где находится исходная позиция переменной.
* параметр 5: `filter_scope: bool = True` — если `True`, ссылки фильтруются по области видимости.

**Описание кода**:
Функция `find_references_in_file` находит все ссылки на указанную переменную в файле. Сначала она определяет язык программирования файла с помощью функции `_detect_language`. Затем она получает парсер для этого языка с помощью функции `_get_parser`. После этого она читает код файла и ищет все вхождения идентификатора, соответствующего указанной переменной, с помощью функции `_find_all_identifiers`. Если включена фильтрация по области видимости (`filter_scope = True`), функция фильтрует найденные ссылки с помощью функции `_filter_references_by_scope`. В результате функция возвращает список кортежей, каждый из которых содержит путь к файлу, номер строки, номер столбца и имя переменной для каждой найденной ссылки.

Функция `find_references_in_file` вызывается из функции `find_references_in_repo` для поиска ссылок на переменную во всём репозитории.

**Примечание**:
При использовании функции `find_references_in_file` важно убедиться, что путь к файлу указан корректно и что расширение файла соответствует заданному в словаре `ext_to_lang`. Также важно убедиться, что параметры `origin_line` и `origin_column` соответствуют действительности.

**Пример вывода**:
Функция возвращает список кортежей, каждый из которых содержит путь к файлу, номер строки, номер столбца и имя переменной для каждой найденной ссылки. Например: `[(rel_path, line, col, variable_name)]`.
***
### FunctionDef _extract_imports(self)
**_extract_imports**: Функция _extract_imports извлекает все импорты из файла.

**parameters**:
* параметр 1: `root: Node` — корневой узел синтаксического дерева, построенного с помощью Tree-sitter.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `language: str` — язык программирования, для которого производится анализ импортов.

**Описание кода**:
Функция _extract_imports анализирует дерево синтаксического анализа Tree-sitter, построенное для заданного файла, и извлекает все импорты. Для этого она использует словарь `patterns`, который содержит шаблоны для поиска импортов в зависимости от языка программирования.

В зависимости от языка программирования (`language`), функция ищет разные типы узлов в дереве (`node.type`). Например, для Python она ищет узлы `import_statement` и `import_from_statement`, а для Java — `import_declaration`. Для каждого найденного импорта она добавляет соответствующее имя модуля или имя, которое было импортировано, в соответствующий словарь `imports`.

Для извлечения текста из узлов дерева используется функция `_get_node_text`, которая декодирует подстроку кода, соответствующую узлу, в строку UTF-8.

Функция `_extract_imports` вызывается функцией `_filter_references_by_imports`, которая фильтрует ссылки на основе анализа импортов. Она использует результаты работы `_extract_imports` для определения того, какие импорты были использованы в файле, и на основе этого фильтрует ссылки, которые могут быть связаны с этими импортами.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности `code`. Убедитесь, что `code` правильно декодируется в UTF-8.
***
### FunctionDef _get_function_full_path(self)
**_get_function_full_path**: Функция _get_function_full_path возвращает полный путь к функции для сопоставления с импортами.

**parameters**:
- параметр 1: `file_path` (str) — путь к файлу, в котором находится функция.
- параметр 2: `function_name` (str) — имя функции.
- параметр 3: `class_name` (str, optional) — имя класса, в котором находится функция (по умолчанию пустая строка).

**Описание кода**:
Функция `_get_function_full_path` принимает путь к файлу, имя функции и опционально имя класса, и возвращает полный путь к функции в формате строки. Для этого она использует `os.path.relpath` для получения относительного пути файла относительно `repo_path`, затем преобразует этот путь в путь модуля и добавляет имя класса и имя функции, если они были предоставлены.

Функция вызывается в контексте анализа ссылок и импортов в проекте. Она помогает определить, какие импорты могут соответствовать определённым ссылкам на функции в коде. Это важно для корректного сопоставления и анализа зависимостей между файлами в проекте.

**Примечание**:
При использовании функции важно учитывать, что `class_name` является необязательным параметром. Если он не указан, функция вернёт путь только до имени функции. Также необходимо убедиться, что `file_path` является корректным путём к файлу в проекте.

**Пример вывода**:
```
"module_name.class_name.function_name" или "module_name.function_name"
```
***
### FunctionDef _find_function_context(self)
**_find_function_context_**: Функция _find_function_context находит контекст функции для заданной позиции в коде, включая имя функции и имя класса, если применимо.

**parameters**:
* параметр 1: **root** (Node) — корневой узел дерева синтаксического анализа.
* параметр 2: **code** (bytes) — код, представленный в виде байтовой последовательности.
* параметр 3: **language** (str) — язык программирования, используемый в коде.
* параметр 4: **target_line** (int) — номер строки в коде, где находится заданная позиция.
* параметр 5: **target_col** (int) — номер столбца в коде, где находится заданная позиция.

**Описание кода**:
Функция _find_function_context ищет узел в дереве синтаксического анализа, который соответствует заданной позиции в коде. Затем она обходит дерево вверх, чтобы найти определение функции и класса. В зависимости от языка программирования, функция ищет узлы с типами "function_definition", "class_definition", "method_declaration" и "function_declaration". Для каждого найденного узла она извлекает имя с помощью функции _get_node_text. Если узел с именем не найден, возвращается None.

Функция вызывается в различных местах для поиска контекста функции по заданной позиции. Например, в функции _filter_references_by_imports она используется для проверки того, является ли ссылка на функцию локальной или импортированной из другого файла.

**Примечание**:
При использовании функции _find_function_context важно учитывать, что она возвращает кортеж из двух значений: имя класса и имя функции. Если соответствующий узел не найден, возвращается None. Убедитесь, что параметры code и language правильно соответствуют коду, который вы анализируете.
***
### FunctionDef _is_likely_import_match(self)
**_is_likely_import_match**: Функция `_is_likely_import_match` проверяет, соответствует ли `target_path` какому-либо импорту, используя нечёткое сопоставление.

**parameters**:
* параметр 1: `imports` (тип: `Dict[str, Set[str]]`) — словарь, содержащий типы импортов и множества путей к ним.
* параметр 2: `target_path` (тип: `str`) — путь, который нужно проверить на соответствие импортам.
* параметр 3: `similarity_threshold` (тип: `float`, значение по умолчанию: `0.4`) — порог сходства для нечёткого сопоставления путей.

**Описание кода**:
Функция `_is_likely_import_match` принимает словарь `imports`, содержащий типы импортов и соответствующие им пути, и строку `target_path`, которую нужно проверить на соответствие этим путям. Если словарь `imports` пуст, функция возвращает `True`, предполагая локальное использование. Затем функция проверяет наличие прямого совпадения `target_path` в `all_imports`. Если прямого совпадения нет, функция проверяет, является ли `target_path` подпутью какого-либо пути в `all_imports` или наоборот. Если и это не даёт результата, функция выполняет нечёткое сопоставление путей с помощью `difflib.SequenceMatcher` и возвращает `True`, если сходство превышает `similarity_threshold`. В противном случае функция возвращает `False`.

**Примечание**:
Обратите внимание, что функция `_is_likely_import_match` использует нечёткое сопоставление для определения сходства между путями. Это может быть полезно в случаях, когда точное совпадение невозможно из-за различий в написании или структуре путей. Однако, если требуется точное соответствие, можно установить `similarity_threshold` ближе к `1.0`.

**Пример вывода**:
```
_is_likely_import_match({"import_type_1": {"path_1", "path_2"}}, "target_path")
```
***
### FunctionDef _filter_references_by_imports(self)
**_filter_references_by_imports_**: Функция _filter_references_by_imports фильтрует ссылки на основе анализа импортов.

**parameters**:
* параметр 1: `references: List[Tuple[str, int, int, str]]` — список ссылок, которые нужно отфильтровать.
* параметр 2: `origin_file: str` — путь к файлу, в котором была найдена исходная ссылка.

**Описание кода**:
Функция _filter_references_by_imports фильтрует список ссылок `references` на основе анализа импортов в файле `origin_file`. Для этого она выполняет следующие действия:

1. Определяет язык программирования файла `origin_file` с помощью функции `_detect_language`.
2. Если язык не определён, возвращает исходный список ссылок.
3. Получает абсолютный путь к файлу `origin_file` и анализирует его с помощью парсера, соответствующего языку программирования.
4. Извлекает все импорты из файла `origin_file` с помощью функции `_extract_imports`.
5. Создаёт словарь `refs_by_file`, в котором для каждого файла, содержащего ссылки, хранит список кортежей `(ref_line, ref_col, ref_name)`, где `ref_line` и `ref_col` — номер строки и столбца ссылки, `ref_name` — имя ссылки.
6. Инициализирует пустой список `filtered_references` для хранения отфильтрованных ссылок.
7. Для каждого файла, содержащего ссылки, кроме `origin_file`, выполняет следующие действия:
    * Определяет язык файла.
    * Если язык не определён, пропускает файл.
    * Анализирует файл с помощью парсера, соответствующего языку программирования.
    * Извлекает код файла.
    * Для каждой ссылки в файле проверяет, является ли она локальной или импортированной.
    * Если ссылка не является локальной, добавляет её в список `filtered_references`, если она соответствует какому-либо импорту.
8. Возвращает список `filtered_references`.

Функция вызывается в контексте поиска ссылок на переменные в репозитории. Она используется для фильтрации ссылок, которые могут быть связаны с импортом из других файлов.

**Примечание**:
При использовании функции _filter_references_by_imports важно убедиться, что список `references` содержит корректные данные, а путь к файлу `origin_file` указан корректно. Также необходимо убедиться, что словарь `self.parsers` содержит парсер для языка программирования файла `origin_file`. В противном случае функция может вернуть некорректные результаты.
***
### FunctionDef _check_local_definition(self)
**_check_local_definition**: Функция _check_local_definition проверяет, определено ли указанное имя локально в том же файле в зависимости от языка программирования.

**parameters**:
* параметр 1: `root: Node` — корень дерева Tree-sitter, представляющего код.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `language: str` — язык программирования.
* параметр 4: `target_name: str` — имя, которое нужно проверить.
* параметр 5: `target_line: int` — номер строки, где находится цель.
* параметр 6: `target_col: int` — номер столбца, где находится цель.

**Описание кода**:
Функция _check_local_definition определяет язык программирования и вызывает соответствующую функцию для проверки локального определения. В зависимости от языка (`python`, `java`, `go`, `kotlin`) она вызывает разные внутренние функции: `_check_python_local_definition`, `_check_java_local_definition`, `_check_go_local_definition` или `_check_kotlin_local_definition`. Это позволяет универсально обрабатывать различные языки программирования.

Функция используется в контексте анализа ссылок и импорта, чтобы определить, являются ли ссылки локальными или импортированными. Она рекурсивно обходит дерево Tree-sitter, начиная с корневого узла, и проверяет, соответствует ли имя узла искомому имени. Если имя найдено в определении функции или класса, функция проверяет, совпадает ли номер строки определения с номером строки цели. Если они не совпадают, функция возвращает `True`, указывая, что имя определено локально.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности `code`. Убедитесь, что `code` правильно декодируется в UTF-8.
***
### FunctionDef _check_python_local_definition(self)
**_check_python_local_definition_**: Функция _check_python_local_definition проверяет, определено ли указанное имя локально в файле Python.

**parameters**:
* параметр 1: `root: Node` — корень дерева Tree-sitter, представляющего код.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `target_name: str` — имя, которое нужно проверить.
* параметр 4: `target_line: int` — номер строки, где находится цель.
* параметр 5: `target_col: int` — номер столбца, где находится цель.

**Описание кода**:
Функция _check_python_local_definition использует обход дерева Tree-sitter для поиска определения указанного имени в файле Python. Она рекурсивно обходит дерево, начиная с корневого узла, и проверяет, соответствует ли имя узла искомому имени. Если имя найдено в определении функции или класса, функция проверяет, совпадает ли номер строки определения с номером строки цели. Если они не совпадают, функция возвращает `True`, указывая, что имя определено локально.

Функция вызывается из функции _check_local_definition, которая определяет язык программирования и вызывает соответствующую функцию для проверки локального определения.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности `code`. Убедитесь, что `code` правильно декодируется в UTF-8.
***
### FunctionDef _check_java_local_definition(self)
**_check_java_local_definition_**: Функция _check_java_local_definition проверяет, определено ли целевое имя локально в файле Java.

**parameters**:
* параметр 1: `root: Node` — корневой узел дерева Tree-sitter, представляющего Java-файл.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `target_name: str` — имя целевого идентификатора, которое нужно проверить.
* параметр 4: `target_line: int` — номер строки, где находится целевой идентификатор.
* параметр 5: `target_col: int` — номер колонки, где находится целевой идентификатор.

**Описание кода**:
Функция _check_java_local_definition использует обход дерева Tree-sitter для поиска узла, соответствующего целевому имени. Она рекурсивно проверяет все дочерние узлы, начиная с корневого. Если целевой идентификатор найден в методе, классе или конструкторе, функция проверяет, совпадает ли его определение с указанной строкой. Если целевой идентификатор не найден в корневом узле или его определение находится в другой строке, функция возвращает `True`, что означает, что идентификатор определён локально. В противном случае функция возвращает `False`.

Функция _check_java_local_definition вызывается из функции _check_local_definition, которая определяет язык и вызывает соответствующую функцию для проверки локального определения.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности `code`. Убедитесь, что `code` правильно декодируется в UTF-8.
***
### FunctionDef _check_go_local_definition(self)
**_check_go_local_definition_**: Функция _check_go_local_definition проверяет, определено ли целевое имя локально в файле на языке Go.

**parameters**:
* параметр 1: `root: Node` — корневой узел синтаксического дерева, полученного с помощью Tree-sitter.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `target_name: str` — имя целевого идентификатора, которое нужно проверить.
* параметр 4: `target_line: int` — номер строки, где находится целевой идентификатор.
* параметр 5: `target_col: int` — номер колонки, где находится целевой идентификатор.

**Описание кода**:
Функция _check_go_local_definition использует обход дерева (walk) для поиска узла с именем, равным `target_name`, в поддереве, начинающемся с `root`. Если такой узел найден, функция сравнивает номер строки (`def_line`), где определено имя, с `target_line`. Если они различаются, функция возвращает `True`, что означает, что имя определено локально. В противном случае функция возвращает `False`.

Функция `_check_go_local_definition` вызывается из функции `_check_local_definition`, которая в зависимости от языка программирования вызывает соответствующие функции для проверки локального определения идентификатора.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности `code`. Убедитесь, что `code` правильно декодируется в UTF-8.
***
### FunctionDef _check_kotlin_local_definition(self)
**_check_kotlin_local_definition_**: Функция _check_kotlin_local_definition проверяет, определено ли целевое имя локально в файле Kotlin.

**parameters**:
* параметр 1: `root: Node` — корневой узел дерева Tree-sitter, представляющего Kotlin-код.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `target_name: str` — имя целевого идентификатора, который нужно проверить.
* параметр 4: `target_line: int` — номер строки, в которой находится целевой идентификатор.
* параметр 5: `target_col: int` — номер колонки, в которой находится целевой идентификатор.

**Описание кода**:
Функция _check_kotlin_local_definition использует обход дерева Tree-sitter для поиска узла, соответствующего целевому имени. Если такой узел найден, функция проверяет, совпадает ли его номер строки с заданным номером строки. Если они не совпадают, функция возвращает `True`, что означает, что идентификатор определён не локально. В противном случае функция возвращает `False`.

Функция _check_kotlin_local_definition вызывается из функции _check_local_definition, которая определяет язык и вызывает соответствующую функцию для проверки локального определения идентификатора.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности `code`. Убедитесь, что `code` правильно декодируется в UTF-8.
***
### FunctionDef find_references_in_repo(self)
**find_references_in_repo**: Функция find_references_in_repo находит все ссылки на указанную переменную во всём репозитории.

**parameters**:
* параметр 1: `variable_name: str` — имя переменной, ссылки на которую нужно найти.
* параметр 2: `origin_file: str` — путь к файлу, в котором была найдена исходная позиция переменной.
* параметр 3: `origin_line: int` — номер строки, где находится исходная позиция переменной.
* параметр 4: `origin_column: int` — номер столбца, где находится исходная позиция переменной.

**Описание кода**:
Функция `find_references_in_repo` осуществляет поиск всех ссылок на указанную переменную в репозитории. Сначала она определяет язык программирования файла `origin_file` с помощью функции `_detect_language`. Затем она получает список файлов для обработки, сортируя их по языку программирования. После этого она последовательно обрабатывает каждый файл, находя в нём ссылки на переменную с помощью функции `find_references_in_file`. Найденные ссылки добавляются в общий список. Затем применяется фильтрация ссылок на основе анализа импортов с помощью функции `_filter_references_by_imports`. В результате функция возвращает список кортежей, каждый из которых содержит путь к файлу, номер строки, номер столбца и имя переменной для каждой найденной ссылки.

Функция вызывается в контексте поиска ссылок на переменные в репозитории. Она используется для поиска всех ссылок на переменную во всём репозитории, включая файлы с разными языками программирования.

**Примечание**:
При использовании функции `find_references_in_repo` важно убедиться, что путь к файлу `origin_file` указан корректно и что расширение файла соответствует заданному в словаре `ext_to_lang`. Также важно убедиться, что параметры `origin_line` и `origin_column` соответствуют действительности.

**Пример вывода**:
Функция возвращает список кортежей, каждый из которых содержит путь к файлу, номер строки, номер столбца и имя переменной для каждой найденной ссылки. Например: `[(rel_path, line, col, variable_name)]`.
***
### FunctionDef get_references(self)
**get_references**: Функция `get_references` предназначена для получения списка ссылок на переменную в исходном коде в заданной позиции и в определённой области поиска.

**parameters**:
* параметр 1: `line: int` — номер строки (на основе 1), в которой находится курсор.
* параметр 2: `column: int` — номер столбца (на основе 0), в котором находится курсор.
* параметр 3: `scope: str = "project"` — область поиска: "file" для поиска только в файле, "project" для поиска по всему репозиторию.

**Описание кода**:
Функция `get_references` сначала проверяет наличие пути к файлу и его существование. Затем она определяет язык файла и использует соответствующий парсер для анализа файла. После этого метод находит идентификатор в указанной позиции и использует его для поиска ссылок. Найденные ссылки преобразуются в экземпляры `ReferenceObject` и возвращаются в виде списка.

Функция `get_references` вызывается в контексте поиска ссылок на переменные в репозитории. Она используется для поиска всех ссылок на переменную во всём репозитории, включая файлы с разными языками программирования.

При использовании функции `get_references` важно убедиться, что путь к файлу указан корректно и что расширение файла соответствует заданному в словаре `ext_to_lang`. Также важно убедиться, что параметры `line` и `column` соответствуют структуре исходного кода.

**Примечание**:
При использовании функции `get_references` может возникнуть ситуация, когда ссылки не найдены или возникли ошибки при анализе файла. В этом случае функция вернёт пустой список. Также необходимо учитывать, что функция может возвращать список, содержащий объекты `ReferenceObject`, которые содержат информацию о найденных ссылках.

**Пример вывода**:
Функция возвращает список объектов `ReferenceObject`, каждый из которых содержит информацию о найденной ссылке. Например: `[ReferenceObject(name='name', line=1, column=1, module_path='path')]`
***
## FunctionDef find_all_referencer
**find_all_referencer**: Функция `find_all_referencer` предназначена для поиска всех ссылок на переменную в исходном коде проекта, имитируя поведение на основе Jedi.

**parameters**:
* параметр 1: `repo_path: str` — путь к репозиторию.
* параметр 2: `variable_name: str` — имя переменной, для которой ищутся ссылки.
* параметр 3: `file_path: str` — путь к файлу (относительно `repo_path`).
* параметр 4: `line_number: int` — номер строки (на основе 1), в которой находится курсор.
* параметр 5: `column_number: int` — номер столбца (на основе 0), в котором находится курсор.
* параметр 6: `in_file_only: bool = False` — если `True`, поиск выполняется только в текущем файле.

**Описание кода**:
Функция `find_all_referencer` создаёт экземпляр `ReferenceFinder` с указанием пути к файлу и использует его для поиска ссылок на переменную. Поиск может быть ограничен текущим файлом или всем репозиторием в зависимости от параметра `in_file_only`. Найденные ссылки фильтруются по имени переменной и возвращаются в виде списка кортежей, содержащих пути к файлам, номера строк и столбцов.

Функция использует класс `ReferenceFinder` для анализа кода и поиска ссылок. `ReferenceFinder` поддерживает несколько языков программирования и использует библиотеку TreeSitter для синтаксического анализа кода. Функция `_get_parser` возвращает экземпляр парсера для заданного языка, а `_get_identifier_at_position` находит имя идентификатора в заданной позиции.

Найденные ссылки фильтруются по имени переменной, и возвращается список кортежей с путями к файлам, номерами строк и столбцов, где были найдены ссылки.

**Примечание**:
При использовании функции `find_all_referencer` важно убедиться, что путь к файлу указан корректно и что расширение файла соответствует заданному в словаре `ext_to_lang`. Также важно убедиться, что параметры `line_number` и `column_number` соответствуют структуре исходного кода.

**Пример вывода**:
Функция возвращает список кортежей, каждый из которых содержит путь к файлу, номер строки и номер столбца, где была найдена ссылка на переменную. Например: `[(file_path, line_number, column_number)]`
