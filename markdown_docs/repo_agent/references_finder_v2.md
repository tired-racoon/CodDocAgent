## ClassDef ReferenceObject
**ReferenceObject**: Функция ReferenceObject имитирует объект-ссылку с атрибутами для имени, строки, столбца и пути к модулю.

**Attributes**:
* параметр 1: name (имя) — строка (str)
* параметр 2: line (строка) — целое число (int)
* параметр 3: column (столбец) — целое число (int)
* параметр 4: module_path (путь к модулю) — строка (str)

**Описание кода**:

Класс ReferenceObject предназначен для представления объектов-ссылок, имитирующих поведение объектов-ссылок в Jedi. Конструктор класса принимает четыре аргумента: имя, номер строки, номер столбца и путь к модулю. Метод `__repr__` возвращает строковое представление объекта-ссылки в формате `<ReferenceObject: {name} at {module_path}:{line}:{column}>`.

Этот класс используется в методе `get_references` класса `ReferenceFinder` для создания экземпляров `ReferenceObject` на основе найденных ссылок в исходном коде. Метод `get_references` принимает аргументы `line` (номер строки), `column` (номер столбца) и `scope` (область поиска) и возвращает список экземпляров `ReferenceObject`.

**Примечание**:

При использовании класса `ReferenceObject` важно убедиться, что все аргументы конструктора переданы корректно, чтобы избежать ошибок при создании экземпляров. Также следует учитывать, что метод `get_references` может возвращать пустой список, если ссылки не найдены или возникли ошибки при обработке исходного кода.

**Пример вывода**:

`<ReferenceObject: {name} at {module_path}:{line}:{column}>`
### FunctionDef __init__(self)
**__init__**: Функция `__init__` инициализирует объект класса `ReferenceObject` с заданными параметрами.

**parameters**:
* параметр 1: `name: str` — имя объекта.
* параметр 2: `line: int` — номер строки в файле, где находится объект.
* параметр 3: `column: int` — номер колонки в строке, где находится объект.
* параметр 4: `module_path: str` — путь к модулю, содержащему объект.

**Описание кода**:
Функция `__init__` принимает четыре параметра и сохраняет их значения в соответствующих атрибутах объекта. Эти атрибуты (`name`, `line`, `column`, `module_path`) будут использоваться для идентификации и доступа к объекту в дальнейшем.

**Примечание**:
При создании экземпляра класса `ReferenceObject` необходимо указать все четыре параметра для корректной инициализации объекта.
***
### FunctionDef __repr__(self)
**__repr__**: Функция `__repr__` имеет значение возврата строкового представления объекта `ReferenceObject`.

**parameters**: параметров у функции нет.

**Описание кода**: функция `__repr__` возвращает строковое представление объекта `ReferenceObject` в формате:
```
"<ReferenceObject: {self.name} at {self.module_path}:{self.line}:{self.column}>"
```
где:
- `self.name` — имя объекта;
- `self.module_path` — путь к модулю, в котором определён объект;
- `self.line` — номер строки, в которой определён объект;
- `self.column` — номер колонки, в которой определён объект.

**Примечание**: использование функции `__repr__` позволяет получить удобное для чтения и понимания представление объекта `ReferenceObject` в виде строки. Это может быть полезно при отладке и тестировании кода.

**Пример вывода**: `<ReferenceObject: example_name at path/to/module:42:10>`
***
## ClassDef ReferenceFinder
**ReferenceFinder**: Класс ReferenceFinder предназначен для поиска ссылок на переменные в исходном коде проекта.

**Attributes**:
* параметр 1: `repo_path` (строка) — путь к корневой директории репозитория.
* параметр 2: `file_path` (строка) — путь к файлу (по умолчанию `None`, в таком случае используется текущий файл).
* `parsers` (словарь) — кэш парсеров для разных языков.
* `identifier_types` (словарь) — типы идентификаторов для каждого языка.
* `scope_types` (словарь) — типы областей видимости для каждого языка.
* `definition_types` (словарь) — типы определений для каждого языка.

**Описание кода**:

Класс ReferenceFinder используется для поиска всех ссылок на переменную в указанном файле или во всём репозитории. При инициализации класс принимает путь к репозиторию и опциональный путь к файлу. Затем он использует парсеры TreeSitter для анализа синтаксиса и поиска идентификаторов.

Класс содержит методы для:
* получения парсера для указанного языка;
* определения языка файла по расширению;
* извлечения текста из узла дерева;
* поиска узла по позиции;
* поиска всех вхождений идентификатора в синтаксическом дереве;
* определения контекста использования идентификатора;
* фильтрации ссылок по области видимости.

Основной метод класса — `get_references`, который возвращает список объектов `ReferenceObject` с информацией о всех ссылках на переменную в указанном файле или во всём репозитории.

Метод `find_references_in_file` используется для поиска ссылок в указанном файле, а метод `find_references_in_repo` — для поиска ссылок во всём репозитории.

**Примечание**:
При использовании класса ReferenceFinder необходимо указать путь к репозиторию и, опционально, путь к файлу. Также важно учесть, что поиск ссылок может быть ограничен определённой областью видимости (файл или проект).

**Пример использования**:

```python
from repo_agent.references_finder_v2 import ReferenceFinder

repo_path = "/path/to/repo"
file_path = "some_file.py"
line_number = 10
column_number = 5

finder = ReferenceFinder(repo_path, file_path)
references = finder.get_references(line_number, column_number, scope="project")
```
### FunctionDef __init__(self)
**__init__**: Функция `__init__` инициализирует объект класса `ReferenceFinder`, задавая параметры для работы с репозиторием и файлами.

**parameters**:
* параметр 1: `repo_path` (обязательный, тип `str`) — путь к репозиторию.
* параметр 2: `file_path` (необязательный, тип `str`) — путь к файлу в репозитории.

**Описание кода**:
Функция `__init__` принимает два параметра: `repo_path` и `file_path`. Путь к репозиторию (`repo_path`) является обязательным параметром. Путь к файлу (`file_path`) является необязательным и может быть установлен по умолчанию как `None`.

Внутри функции происходит следующее:
* значение `repo_path` сохраняется в атрибуте `self.repo_path`;
* значение `file_path` сохраняется в атрибуте `self.file_path`;
* создаётся пустой словарь `self.parsers` для кэширования парсеров различных языков;
* инициализируются словари `self.identifier_types`, `self.scope_types` и `self.definition_types`, которые содержат информацию об идентификаторах, областях видимости и типах определений для различных языков программирования (Python, Java, Go, Kotlin).

**Примечание**:
При использовании функции `__init__` необходимо указать путь к репозиторию. Путь к файлу может быть указан дополнительно.
***
### FunctionDef _get_parser(self)
**_get_parser_**: Функция _get_parser получает или создаёт парсер для заданного языка программирования.

**parameters**:
- параметр 1: language (str) — язык программирования.

**Описание кода**:
Функция _get_parser принимает на вход строку language, которая представляет собой язык программирования. Если указанный язык отсутствует в словаре парсеров (self.parsers), создаётся новый экземпляр парсера TreeSitterParser с использованием пути к репозиторию и фиктивного пути файла, сформированного на основе языка. Затем созданный или полученный парсер возвращается.

Функция используется в контексте поиска ссылок на переменные в файлах, где для каждого языка программирования требуется соответствующий парсер.

**Примечание**:
При использовании функции _get_parser важно убедиться, что переданный язык программирования существует в словаре self.parsers. В противном случае будет создан новый парсер с использованием фиктивного пути файла, что может повлиять на корректность работы.
***
### FunctionDef _get_extension(self)
**_get_extension**: Функция _get_extension возвращает расширение файла для заданного языка программирования.

**parameters**:
- параметр 1: language (str) — язык программирования.

**Описание кода**:
Функция _get_extension принимает на вход строку language, которая представляет собой язык программирования. Затем она обращается к словарю extensions, где каждому языку соответствует его расширение файла. Если язык найден в словаре, возвращается соответствующее ему расширение. В противном случае возвращается значение "txt". Функция используется для получения расширения файла, которое будет использоваться при создании парсера для заданного языка.

**Примечание**:
При использовании функции _get_extension важно убедиться, что переданный язык программирования существует в словаре extensions. В противном случае будет возвращено расширение "txt", что может быть некорректным для данного языка.

**Пример вывода**:
```
_get_extension("python") # Вернет "py"
_get_extension("java") # Вернет "java"
_get_extension("go") # Вернет "go"
_get_extension("kotlin") # Вернет "kt"
_get_extension("unknown") # Вернет "txt"
```
***
### FunctionDef _detect_language(self)
**_detect_language**: Функция _detect_language определяет язык программирования на основе расширения файла.

**parameters**:
* параметр 1: `file_path` — путь к файлу.

**Описание кода**:
Функция _detect_language принимает путь к файлу и определяет язык программирования на основе его расширения. В словаре `ext_to_lang` заданы соответствия между расширениями файлов и языками программирования. Затем функция разбивает путь к файлу на имя файла и его расширение с помощью `os.path.splitext`. После этого она ищет соответствие между расширением файла и языком программирования в словаре `ext_to_lang` и возвращает соответствующий язык, если таковой имеется.

Функция _detect_language используется в следующих ситуациях:
* В функции `find_references_in_file` для определения языка программирования файла, чтобы затем использовать соответствующий парсер для анализа кода.
* В функции `find_references_in_repo` для определения языка программирования файла и дальнейшей обработки файлов в репозитории.
* В функции `get_references` для определения языка программирования файла перед поиском ссылок на переменную.

**Примечание**:
Обратите внимание, что функция _detect_language работает только с файлами, имеющими известные расширения, которые указаны в словаре `ext_to_lang`. Если файл имеет нестандартное расширение или его нет в словаре, функция вернёт `None`.
***
### FunctionDef _get_node_text(self)
**_get_node_text_**: Функция _get_node_text извлекает текст из узла, заданного в дереве Tree-sitter.

**parameters**:
* параметр 1: `node: Node` — узел дерева Tree-sitter, из которого нужно извлечь текст.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности, из которой извлекается текст.

**Описание кода**:
Функция _get_node_text принимает узел и байтовую последовательность кода и извлекает текст, соответствующий заданному узлу. Если узел не задан или является пустым, функция возвращает пустую строку. В противном случае функция возвращает строку, содержащую текст, соответствующий байтам, заданным узлом в предоставленной байтовой последовательности кода.

Функция используется в следующих ситуациях:
* В функции `_get_identifier_at_position` для извлечения имени идентификатора в определённой позиции.
* В функции `_find_all_identifiers` для поиска всех вхождений идентификатора в синтаксическом дереве.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности и корректную структуру дерева Tree-sitter.

**Пример вывода**:
```
_get_node_text(node, code)
```
***
### FunctionDef _find_node_at_position(self)
**_find_node_at_position_**: Функция _find_node_at_position находит наиболее специфический узел в заданном положении (номер строки и столбца).

**parameters**:
* параметр 1: `root` — корневой узел дерева синтаксического анализа (Node).
* параметр 2: `line` — номер строки (начиная с 1).
* параметр 3: `column` — номер столбца (начиная с 0).

**Описание кода**:
Функция _find_node_at_position использует рекурсивный подход для поиска узла в заданном положении. Она сначала проверяет, находится ли заданное положение в пределах границ текущего узла. Если да, то функция проверяет, является ли текущий узел искомым. Если нет, то функция рекурсивно ищет узел в дочерних элементах текущего узла. Если искомый узел найден в дочерних элементах, функция возвращает его. Если нет, то возвращается текущий узел.

Функция _find_node_at_position вызывается в следующих ситуациях:
* для поиска узла в заданном положении в дереве синтаксического анализа;
* для получения имени идентификатора в заданном положении в дереве синтаксического анализа;
* для проверки, находятся ли две позиции в одном и том же контексте в дереве синтаксического анализа.

**Примечание**:
Обратите внимание, что функция _find_node_at_position использует 0-базированную систему координат для столбцов в дереве синтаксического анализа. Также учтите, что функция возвращает `None`, если заданное положение не соответствует ни одному узлу в дереве.
***
### FunctionDef _get_identifier_at_position(self)
**_get_identifier_at_position_**: Функция _get_identifier_at_position извлекает имя идентификатора в заданной позиции в исходном коде.

**parameters**:
* параметр 1: `root: Node` — корневой узел дерева синтаксического анализа (Node).
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `language: str` — язык программирования, используемый в коде.
* параметр 4: `line: int` — номер строки, в которой находится идентификатор (начиная с 1).
* параметр 5: `column: int` — номер столбца, в котором находится идентификатор (начиная с 0).

**Описание кода**:
Функция _get_identifier_at_position использует рекурсивный подход для поиска идентификатора в заданной позиции. Сначала она находит узел в дереве синтаксического анализа, который соответствует заданной позиции. Затем она проверяет, является ли этот узел идентификатором. Если да, то функция возвращает текст узла. Если нет, то функция ищет идентификатор в родительских узлах или в дочерних узлах. Если идентификатор найден, функция возвращает его текст. Если идентификатор не найден, функция возвращает `None`.

Функция используется в следующих ситуациях:
* В функции `get_references` для получения имени идентификатора в заданной позиции в дереве синтаксического анализа.
* В функции `find_all_referencer` для поиска всех вхождений идентификатора в синтаксическом дереве.

**Примечание**:
Обратите внимание, что функция предполагает корректное представление кода в байтовой последовательности и корректную структуру дерева Tree-sitter. Также учтите, что функция использует 0-базированную систему координат для столбцов в дереве синтаксического анализа.

**Пример вывода**:
```
_get_identifier_at_position(root, code, language, line, column)
```
***
### FunctionDef _find_all_identifiers(self)
**_find_all_identifiers_**: Функция _find_all_identifiers находит все вхождения идентификатора в синтаксическом дереве.

**parameters**:
* параметр 1: `root: Node` — корневой узел синтаксического дерева, созданного с помощью Tree-sitter.
* параметр 2: `code: bytes` — код, представленный в виде байтовой последовательности.
* параметр 3: `language: str` — язык программирования, используемый в коде.
* параметр 4: `target_name: str` — имя идентификатора, которое нужно найти.

**Описание кода**:
Функция _find_all_identifiers обходит синтаксическое дерево, начиная с корневого узла, и ищет все узлы, тип которых соответствует типам идентификаторов для заданного языка программирования. Если тип узла соответствует, функция извлекает текст из узла и сравнивает его с искомым именем идентификатора. Если они совпадают, функция записывает в список `matches` информацию о позиции узла в коде (номер строки и столбца) и контексте его использования. Затем функция рекурсивно обходит все дочерние узлы текущего узла.

Функция вызывается из функции `find_references_in_file`, которая ищет все ссылки на переменную в файле. Для этого она использует _find_all_identifiers для поиска всех вхождений идентификатора в синтаксическом дереве, созданном на основе файла.

**Примечание**:
При использовании функции _find_all_identifiers необходимо убедиться, что параметры `root`, `code`, `language` и `target_name` являются допустимыми. Также важно учитывать, что функция предполагает корректное представление кода в байтовой последовательности и корректную структуру дерева Tree-sitter.

**Пример вывода**:
Функция может быть вызвана следующим образом:
```
_find_all_identifiers(root, code_bytes, language, variable_name)
```
***
### FunctionDef _get_reference_context(self)
**_get_reference_context_**: Функция _get_reference_context определяет контекст использования узла в дереве (определение, использование и т. д.).

**parameters**:
* параметр 1: node (Node) — узел, для которого определяется контекст.
* параметр 2: language (str) — язык программирования, используемый в коде.

**Описание кода**:
Функция _get_reference_context принимает два параметра: node и language. Если у узла node нет родителя, функция возвращает «usage». Затем она проверяет, есть ли у родителя узла node тип, соответствующий определению в языке программирования. Если да, возвращается значение «definition». В противном случае функция продолжает обход дерева вверх по иерархии.

Для языка Python функция проверяет, является ли текущий узел назначением, и содержит ли он целевой узел. Если да, возвращается «definition». Также проверяется, является ли текущий узел определением функции или класса, и содержит ли он целевой узел. Если да, возвращается «definition».

Для языка Java функция проверяет, является ли текущий узел объявлением переменной, и содержит ли он целевой узел. Если да, возвращается «definition».

**Примечание**:
При использовании функции _get_reference_context необходимо убедиться, что оба параметра (node и language) являются допустимыми.

**Пример вывода**:
Функция может быть вызвана следующим образом:
```
_get_reference_context(node, language)
```
***
### FunctionDef _node_contains_position(self)
**_node_contains_position_**: Функция _node_contains_position проверяет, содержит ли узел-контейнер целевой узел.

**parameters**:
* параметр 1: container (Node) — узел-контейнер.
* параметр 2: target (Node) — целевой узел.

**Описание кода**:
Функция _node_contains_position принимает два параметра: container и target, которые являются узлами (Node). Если какой-либо из параметров отсутствует, функция возвращает False. Затем функция вызывает вспомогательную функцию check_children, которая рекурсивно проверяет, содержится ли целевой узел в узле-контейнере. Если целевой узел найден в контейнере, функция возвращает True, в противном случае — False.

В функции _get_reference_context используется _node_contains_position для определения контекста использования узла в дереве. Если текущий узел является родителем целевого узла, функция проверяет, есть ли у текущего узла тип, соответствующий определению в языке программирования. Если да, возвращается значение "definition". В противном случае функция продолжает обход дерева вверх по иерархии.

**Примечание**:
При использовании функции _node_contains_position необходимо убедиться, что оба параметра (container и target) являются допустимыми узлами в дереве.

**Пример вывода**:
Функция может быть вызвана следующим образом:
```
_node_contains_position(container, target)
```
***
### FunctionDef _is_same_scope(self)
**_is_same_scope**: Функция _is_same_scope проверяет, находятся ли две позиции в одном контексте (scope) в дереве синтаксического анализа.

**parameters**:
* параметр 1: `root` — корневой узел дерева синтаксического анализа (Node).
* параметр 2: `language` — язык программирования, для которого производится поиск контекста.
* параметр 3: `pos1` — кортеж с координатами первой позиции (номер строки и столбца).
* параметр 4: `pos2` — кортеж с координатами второй позиции (номер строки и столбца).

**Описание кода**:
Функция _is_same_scope использует рекурсивный подход для поиска контекста (scope) для каждой из двух заданных позиций в дереве синтаксического анализа. Сначала она определяет типы контекстов, которые могут быть актуальны для заданного языка программирования. Затем для каждой позиции находит ближайший охватывающий узел контекста. После этого сравнивает найденные узлы контекста и возвращает `True`, если они совпадают, иначе `False`.

Функция _is_same_scope вызывается в контексте фильтрации ссылок (references) на основе правил контекста. Она используется для определения, находятся ли ссылки в том же контексте, что и исходная позиция, чтобы отфильтровать их соответствующим образом.

**Примечание**:
Обратите внимание, что функция _is_same_scope использует вспомогательную функцию `find_enclosing_scope` для поиска охватывающего узла контекста. Также учтите, что функция возвращает `True` или `False` в зависимости от того, находятся ли позиции в одном контексте.
***
### FunctionDef _filter_references_by_scope(self)
**_filter_references_by_scope**: Функция _filter_references_by_scope фильтрует ссылки на основе правил контекста.

**parameters**:
* параметр 1: `references` — список кортежей, где каждый кортеж содержит номер строки, номер столбца и контекст ссылки.
* параметр 2: `origin_pos` — кортеж с координатами исходной позиции (номер строки и столбца).
* параметр 3: `root` — корневой узел дерева синтаксического анализа (Node).
* параметр 4: `language` — язык программирования, для которого производится поиск контекста.

**Описание кода**:
Функция _filter_references_by_scope перебирает все ссылки и проверяет, находятся ли они в том же контексте, что и исходная позиция. Если ссылка является определением, она всегда включается в результат. Для ссылок-использований функция вызывает _is_same_scope, чтобы проверить, находятся ли они в том же контексте, что и определение. Если да, то ссылка включается в результат. Функция возвращает отфильтрованный список ссылок.

Функция _filter_references_by_scope вызывается в контексте поиска ссылок на переменную в файле. Она используется для фильтрации ссылок на основе правил контекста, чтобы исключить ссылки, которые не относятся к исходной позиции.

**Примечание**:
Обратите внимание, что функция _filter_references_by_scope использует вспомогательную функцию _is_same_scope для проверки контекста. Также учтите, что функция возвращает список ссылок, отфильтрованных на основе правил контекста.
***
### FunctionDef find_references_in_file(self)
**find_references_in_file**: Функция find_references_in_file находит все ссылки на переменную в указанном файле.

**parameters**:
* параметр 1: `file_path: str` — путь к файлу, в котором нужно найти ссылки.
* параметр 2: `variable_name: str` — имя переменной, ссылки на которую нужно найти.
* параметр 3: `origin_line: int` — номер строки, в которой находится исходная позиция переменной.
* параметр 4: `origin_column: int` — номер столбца, в котором находится исходная позиция переменной.
* параметр 5: `filter_scope: bool = True` — флаг, указывающий, нужно ли применять фильтрацию ссылок по области видимости (по умолчанию `True`).

**Описание кода**:
Функция `find_references_in_file` ищет все ссылки на указанную переменную в файле, указанном в `file_path`. Для этого она использует парсер, соответствующий языку программирования файла, чтобы проанализировать код и найти все вхождения идентификатора, соответствующего `variable_name`. Если `filter_scope` равен `True`, функция фильтрует найденные ссылки, оставляя только те, которые находятся в той же области видимости, что и исходная позиция переменной.

Функция вызывается из `find_references_in_repo` для поиска ссылок на переменную во всём репозитории. Она также используется в `get_references` для поиска ссылок на переменную в файле по указанным координатам.

Функция `find_references_in_file` использует следующие вспомогательные функции:
* `_detect_language` — для определения языка программирования файла по его расширению.
* `_get_parser` — для получения или создания парсера, соответствующего языку программирования файла.
* `_find_all_identifiers` — для поиска всех вхождений идентификатора в синтаксическом дереве.
* `_filter_references_by_scope` — для фильтрации ссылок по области видимости.

**Примечание**:
При использовании функции `find_references_in_file` важно убедиться, что `file_path` указывает на существующий файл, а `variable_name` соответствует идентификатору в этом файле. Также необходимо учитывать, что функция предполагает корректное представление кода в файле и корректную структуру дерева синтаксического анализа.

**Пример вывода**:
Функция может быть вызвана следующим образом:
```
references = find_references_in_file(file_path, variable_name, origin_line, origin_column, filter_scope)
```
Результатом будет список кортежей, где каждый кортеж содержит путь к файлу, номер строки, номер столбца и имя переменной.
***
### FunctionDef find_references_in_repo(self)
**find_references_in_repo**: Функция `find_references_in_repo` находит все ссылки на переменную во всём репозитории.

**parameters**:
* параметр 1: `variable_name: str` — имя переменной, ссылки на которую нужно найти.
* параметр 2: `origin_file: str` — путь к файлу, в котором находится исходная позиция переменной.
* параметр 3: `origin_line: int` — номер строки, в которой находится исходная позиция переменной.
* параметр 4: `origin_column: int` — номер столбца, в котором находится исходная позиция переменной.

**Описание кода**:
Функция `find_references_in_repo` ищет все ссылки на указанную переменную в репозитории. Для этого она сначала определяет язык программирования файла, в котором находится исходная позиция переменной, с помощью функции `_detect_language`. Затем она сортирует файлы в репозитории по языку программирования и обрабатывает их в соответствии с этим порядком.

Для каждого файла функция вызывает `find_references_in_file`, чтобы найти ссылки на переменную. Если файл имеет тот же язык программирования, что и исходный файл, функция фильтрует ссылки по области видимости.

Функция возвращает список кортежей, где каждый кортеж содержит путь к файлу, номер строки, номер столбца и имя переменной.

Функция `find_references_in_repo` используется в следующих ситуациях:
* В функции `get_references` для поиска ссылок на переменную в репозитории по указанным координатам.

**Примечание**:
При использовании функции `find_references_in_repo` важно убедиться, что `origin_file` указывает на существующий файл, а `variable_name` соответствует идентификатору в этом файле. Также необходимо учитывать, что функция предполагает корректное представление кода в файле и корректную структуру дерева синтаксического анализа.

**Пример вывода**:
```
references = find_references_in_repo(variable_name, origin_file, origin_line, origin_column)
```
Результатом будет список кортежей, где каждый кортеж содержит путь к файлу, номер строки, номер столбца и имя переменной.
***
### FunctionDef get_references(self)
**get_references**: Функция `get_references` предназначена для получения списка ссылок на переменную в указанном файле или во всём репозитории в зависимости от области поиска.

**parameters**:
* параметр 1: `line: int` — номер строки (начиная с 1), в которой находится позиция переменной.
* параметр 2: `column: int` — номер столбца (начиная с 0), в котором находится позиция переменной.
* параметр 3: `scope: str = "project"` — область поиска: "file" для поиска только в файле или "project" для поиска во всём репозитории.

**Описание кода**:
Функция `get_references` использует парсер, соответствующий языку программирования файла, для анализа кода и поиска всех вхождений идентификатора, соответствующего переменной. В зависимости от параметра `scope`, функция ищет ссылки либо только в указанном файле, либо во всём репозитории.

Для каждого найденного вхождения функция создаёт экземпляр `ReferenceObject`, который содержит информацию о пути к файлу, номере строки, номере столбца и имени переменной. Затем функция возвращает список экземпляров `ReferenceObject`.

Функция `get_references` вызывается из `find_all_referencer` для поиска ссылок на переменную в репозитории по указанным координатам.

**Примечание**:
При использовании функции `get_references` важно убедиться, что `line` и `column` указывают на существующую позицию в файле, а `scope` задан корректно. Также необходимо учитывать, что функция предполагает корректное представление кода в файле и корректную структуру дерева синтаксического анализа.

**Пример вывода**:
```
references = get_references(line, column, scope)
```
Результатом будет список экземпляров `ReferenceObject`, представляющих ссылки на переменную.
***
## FunctionDef find_all_referencer
**find_all_referencer**: Функция `find_all_referencer` предназначена для поиска всех ссылок на переменную в указанном файле или во всём репозитории.

**parameters**:
* параметр 1: `repo_path: str` — путь к корневой директории репозитория.
* параметр 2: `variable_name: str` — имя переменной, для которой нужно найти ссылки.
* параметр 3: `file_path: str` — путь к файлу (относительно `repo_path`).
* параметр 4: `line_number: int` — номер строки (начиная с 1), в которой находится позиция переменной.
* параметр 5: `column_number: int` — номер столбца (начиная с 0), в котором находится позиция переменной.
* параметр 6: `in_file_only: bool = False` — если `True`, поиск выполняется только в текущем файле.

**Описание кода**:
Функция `find_all_referencer` использует класс `ReferenceFinder` для анализа кода и поиска всех вхождений идентификатора, соответствующего переменной. В зависимости от параметра `in_file_only`, функция ищет ссылки либо только в указанном файле, либо во всём репозитории.

Для каждого найденного вхождения функция фильтрует ссылки, исключая исходную позицию. Затем функция возвращает список кортежей, содержащих путь к файлу, номер строки и номер столбца для каждой найденной ссылки.

Функция `find_all_referencer` вызывается для поиска ссылок на переменную в репозитории по указанным координатам.

**Примечание**:
При использовании функции `find_all_referencer` важно убедиться, что `line_number` и `column_number` указывают на существующую позицию в файле, а `in_file_only` задан корректно. Также необходимо учитывать, что функция предполагает корректное представление кода в файле и корректную структуру дерева синтаксического анализа.

**Пример вывода**:
```
filtered_refs = find_all_referencer(repo_path, variable_name, file_path, line_number, column_number, in_file_only)
```
Результатом будет список кортежей, представляющих ссылки на переменную.
