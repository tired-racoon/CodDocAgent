## ClassDef ChangeDetector
**ChangeDetector**: Функция ChangeDetector предназначена для обнаружения изменений в репозитории Git и работы с файлами, которые были добавлены или изменены в индексе.

**Attributes**:
* параметр 1: `repo_path` (str) — путь к репозиторию.

**Описание кода**:

Класс ChangeDetector предназначен для работы с репозиториями Git и обнаружения изменений в них. Он инициализируется с путём к репозиторию и предоставляет методы для работы с файлами, которые были добавлены или изменены в индексе.

Методы класса:

* `__init__(self, repo_path)` — инициализирует объект ChangeDetector с путём к репозиторию.
* `get_staged_pys(self)` — возвращает словарь с путями к добавленным файлам Python в индексе и указанием, являются ли они новыми файлами.
* `get_file_diff(self, file_path, is_new_file)` — получает изменения, сделанные в указанном файле. Для новых файлов сначала добавляет их в индекс, а затем получает разницу. Для уже существующих файлов получает разницу с HEAD.
* `parse_diffs(self, diffs)` — анализирует содержимое разницы и извлекает информацию об добавленных и удалённых объектах.
* `identify_changes_in_structure(self, changed_lines, structures)` — идентифицирует структуры (функции или классы), в которых произошли изменения.
* `get_to_be_staged_files(self)` — получает список файлов, которые должны быть добавлены в индекс.
* `add_unstaged_files(self)` — добавляет файлы, которые должны быть добавлены в индекс, в индекс.

**Примечание**:
При использовании метода `get_staged_pys` необходимо учитывать, что логика библиотеки GitPython отличается от стандартной Git. Параметр `R=True` в методе `diff` изменяет логику сравнения, чтобы новые файлы в индексе корректно отображались как добавленные.

**Output Example**:
Не применимо для данного класса.
### FunctionDef __init__(self, repo_path)
**__init__**: Функция __init__ инициализирует объект ChangeDetector.

**parameters**:
* параметр 1: repo_path (str) — путь к репозиторию.

**Описание кода**:
Функция __init__ принимает путь к репозиторию (repo_path) в качестве параметра и сохраняет его в атрибуте self.repo_path. Затем она создаёт объект git.Repo, передавая путь к репозиторию в качестве аргумента, и сохраняет его в атрибуте self.repo.

**Примечание**:
При использовании функции __init__ необходимо убедиться, что путь к репозиторию (repo_path) является корректным и доступным.
***
### FunctionDef get_staged_pys(self)
**get_staged_pys**: Функция `get_staged_pys` возвращает словарь добавленных файлов Python в репозитории, которые были подготовлены к коммиту (`staged`), то есть файлы, добавленные с помощью команды `git add`.

**parameters**: параметров у функции нет.

**Описание кода**: функция `get_staged_pys` использует библиотеку `GitPython` для обнаружения изменений в индексе (staging area) репозитория по сравнению с последним коммитом (`HEAD`). Она ищет файлы с расширениями `.py`, `.java`, `.go`, `.kt`, `.kts`, которые были добавлены (`change_type == "A"`) или изменены (`change_type == "M"`). Для корректной работы логики сравнения используется параметр `R=True`, который инвертирует логику сравнения, принятую в `GitPython`: последний коммит (`HEAD`) рассматривается как старое состояние, а текущая область подготовки (`Index`) — как новое состояние.

Функция заполняет словарь `staged_files`, где ключами являются пути к файлам, а значениями — булевы значения, указывающие, является ли файл новым (`True`) или был изменён (`False` для изменённых файлов не применяется, применяется только для новых).

**Примечание**: обратите внимание, что логика библиотеки `GitPython` отличается от стандартной `git`. Параметр `R=True` используется для инвертирования логики сравнения версий. Также учтите, что новый файл в текущей области подготовки будет показан как удалённый в `HEAD`, если не использовать `R=True`.

**Пример вывода**:
```
{
    "path/to/new_file.py": True
}
```
***
### FunctionDef get_file_diff(self, file_path, is_new_file)
**get_file_diff**: Функция `get_file_diff` предназначена для получения изменений, внесённых в указанный файл.

**parameters**:
* `file_path (str)`: относительный путь к файлу.
* `is_new_file (bool)`: указывает, является ли файл новым.

**Описание кода**:
Функция `get_file_diff` принимает два аргумента: путь к файлу и флаг, указывающий, является ли файл новым. В зависимости от значения флага `is_new_file`, функция выполняет разные действия для получения различий.

Если файл новый (`is_new_file` равен `True`), функция добавляет файл в область подготовки с помощью команды `git add`, а затем получает различия из области подготовки с помощью команды `git diff --staged`.

Если файл не новый (`is_new_file` равен `False`), функция получает различия из HEAD с помощью команды `git diff HEAD`.

В обоих случаях функция возвращает список изменений, внесённых в файл, в виде списка строк.

**Примечание**:
При использовании функции `get_file_diff` необходимо убедиться, что путь к файлу указан правильно и что у пользователя есть права на выполнение команд `git`.

**Пример вывода**:
```
[
    "Изменение 1",
    "Изменение 2",
    "Изменение 3"
]
```
***
### FunctionDef parse_diffs(self, diffs)
**parse_diffs**: Функция parse_diffs анализирует содержимое различий и извлекает информацию о добавленных и удалённых объектах, которые могут быть классами или функциями.

**parameters**:
* параметр 1: diffs (list) — список, содержащий содержимое различий. Получен с помощью функции get_file_diff() внутри класса.

**Описание кода**:
Функция parse_diffs принимает на вход список diffs, который содержит данные о различиях в файлах. Она анализирует каждую строку в diffs и определяет, является ли она добавленной или удалённой. Для этого используется регулярное выражение для извлечения номеров строк, с которых начинаются изменения, и затем анализируется начало каждой строки. Если строка начинается с "+", она считается добавленной, если с "-", то удалённой. Извлечённая информация сохраняется в словаре changed_lines, который затем возвращается в качестве результата.

**Примечание**:
При анализе изменений важно помнить, что в git diff модификация строки представляется как удаление и добавление. Поэтому для точного определения того, что объект был добавлен, необходимо использовать функцию get_added_objs().

**Пример вывода**:
```
{
    'added': [(86, '    '), (87, '    def to_json_new(self, comments = True):'), (88, '        data = {'), (89, '            "name": self.node_name,')...(95, '')], 
    'removed': []
}
```
***
### FunctionDef identify_changes_in_structure(self, changed_lines, structures)
**identify_changes_in_structure**: Функция `identify_changes_in_structure` предназначена для выявления структур (функций или классов), в которых произошли изменения, путём анализа изменённых строк кода.

**parameters**:
- параметр 1: `changed_lines` (dict) — словарь, содержащий номера строк, где произошли изменения, в формате `{'added': [(line number, change content)], 'removed': [(line number, change content)]}`
- параметр 2: `structures` (list) — список структур функций или классов, полученных из `get_functions_and_classes`, каждая структура представлена кортежем `(structure_type, name, start_line, end_line, parent_structure)`

**Описание кода**:
Функция `identify_changes_in_structure` анализирует изменённые строки и определяет, какие структуры (функции или классы) были затронуты этими изменениями. Для каждой изменённой строки проверяется, находится ли она в диапазоне строк, соответствующих определённой структуре. Если строка находится в этом диапазоне, структура считается изменённой, и её имя и имя родительской структуры добавляются в соответствующие множества в словаре `changes_in_structures`.

Словарь `changes_in_structures` имеет два ключа: `'added'` и `'removed'`, которые содержат множества кортежей `(name, parent_structure)`, где `name` — имя изменённой структуры, а `parent_structure` — имя родительской структуры.

**Примечание**:
При использовании функции `identify_changes_in_structure` необходимо учитывать, что она работает с данными, полученными из других частей системы, и требует корректного формирования списков `changed_lines` и `structures`.

**Output Example**:
`{'added': {('PipelineAutoMatNode', None), ('to_json_new', 'PipelineAutoMatNode')}, 'removed': set()}`
***
### FunctionDef get_to_be_staged_files(self)
**get_to_be_staged_files**: Функция `get_to_be_staged_files` извлекает все файлы в репозитории, которые не были добавлены в стадию (staging) и соответствуют одному из условий: файл с изменённым на .md расширением соответствует уже добавленному в стадию файлу, либо путь файла совпадает с полем `project_hierarchy` в настройках конфигурации.

**parameters**: нет параметров.

**Описание кода**: функция `get_to_be_staged_files` выполняет следующие действия:
* Получает список файлов, которые уже были добавлены в стадию, используя метод `diff` объекта `repo.index`.
* Определяет иерархию проекта и список неотслеживаемых файлов.
* Проходит по списку неотслеживаемых файлов и добавляет в список `to_be_staged_files` файлы, которые начинаются с имени папки markdown документов, а также файлы, соответствующие условиям.
* Получает список файлов, которые не были добавлены в стадию, и добавляет в `to_be_staged_files` файлы, соответствующие условиям.
* Возвращает список путей к файлам, которые нужно добавить в стадию.

Функция `add_unstaged_files` вызывает `get_to_be_staged_files` для получения списка файлов, которые нужно добавить в стадию, и затем выполняет команду `git add` для каждого файла из этого списка.

**Примечание**: при использовании функции `get_to_be_staged_files` необходимо учитывать иерархию проекта и настройки конфигурации. Также следует обратить внимание на то, что функция возвращает список путей к файлам в репозитории, а не сами файлы.

**Пример вывода**:
```
[
    'path/to/file1.md',
    'path/to/file2.md',
    'path/to/project_hierarchy'
]
```
***
### FunctionDef add_unstaged_files(self)
**add_unstaged_files**: Функция `add_unstaged_files` добавляет в область подготовки (staging area) файлы, которые соответствуют определённым условиям и ещё не были добавлены в эту область.

**parameters**: нет параметров.

**Описание кода**: функция `add_unstaged_files` выполняет следующие действия:
* Вызывает функцию `get_to_be_staged_files`, чтобы получить список файлов, которые нужно добавить в стадию.
* Для каждого файла из этого списка выполняет команду `git add`.

Функция `get_to_be_staged_files` извлекает все файлы в репозитории, которые не были добавлены в стадию и соответствуют одному из условий:
* Файл с изменённым на .md расширением соответствует уже добавленному в стадию файлу.
* Путь файла совпадает с полем `project_hierarchy` в настройках конфигурации.

После получения списка файлов, которые нужно добавить в стадию, функция `add_unstaged_files` выполняет команду `git add` для каждого файла из этого списка.

**Примечание**: при использовании функции `get_to_be_staged_files` необходимо учитывать иерархию проекта и настройки конфигурации. Также следует обратить внимание на то, что функция возвращает список путей к файлам в репозитории, а не сами файлы.

**Пример вывода**:
```
[
    'path/to/file1.md',
    'path/to/file2.md',
    'path/to/project_hierarchy'
]
```
***
