## ClassDef FileHandler
**FileHandler**: Класс FileHandler предназначен для работы с файлами в репозитории, включая определение языка программирования файла, чтение и запись файлов, а также парсинг кода с использованием библиотеки Tree-sitter.

**Attributes**:
* **repo_path**: путь к репозиторию.
* **file_path**: путь к файлу.
* **project_hierarchy**: структура проекта.
* **language_name**: определённый язык программирования файла.
* **ts_language**: язык программирования для использования с библиотекой Tree-sitter.
* **parser**: экземпляр класса Parser для парсинга кода.
* **code**: код файла.
* **root**: корневой узел дерева синтаксического анализа.

**Описание кода**:

Класс FileHandler предоставляет методы для работы с файлами в репозитории. В конструкторе класса указываются путь к репозиторию и путь к файлу. Затем определяется язык программирования файла и инициализируется соответствующий экземпляр класса Parser.

Методы read_file и write_file позволяют читать содержимое файла и записывать в файл новое содержимое. Метод get_modified_file_versions возвращает текущую и предыдущую версии файла из git.

Методы parse_code и parse_file используются для парсинга кода с использованием библиотеки Tree-sitter. Метод parse_code принимает строку с кодом и возвращает корневой узел дерева синтаксического анализа. Метод parse_file открывает файл, читает его содержимое и вызывает метод parse_code.

Методы extract_name и extract_parameters извлекают имя функции и параметры из узла дерева синтаксического анализа. Метод get_functions_and_classes возвращает список функций и классов из parsed code.

Метод generate_file_structure генерирует структуру для одного файла, а метод generate_overall_structure генерирует структуру для всего репозитория. Метод convert_to_markdown_file преобразует структуру файла в формат markdown.

**Примечание**:
При использовании класса FileHandler необходимо указать путь к репозиторию и путь к файлу. Также необходимо учитывать, что методы класса могут генерировать исключения в случае ошибок.

**Пример вывода**:
Не применимо для данного класса.
### FunctionDef __init__(self, repo_path, file_path)
**__init__**: Функция `__init__` инициализирует объект класса `FileHandler`, задавая путь к репозиторию и файлу, определяет язык программирования файла и создаёт соответствующие внутренние атрибуты.

**parameters**:
* параметр 1: `repo_path` — путь к репозиторию.
* параметр 2: `file_path` — путь к файлу.

**Описание кода**: Функция `__init__` принимает два параметра: `repo_path` и `file_path`. Она устанавливает атрибуты `self.repo_path` и `self.file_path` равными переданным значениям. Затем она использует объект `SettingsManager` для получения настроек проекта и создаёт атрибут `self.project_hierarchy`, который представляет собой путь к иерархии проекта в репозитории.

Далее функция определяет язык программирования файла с помощью функции `_detect_language`, если путь к файлу не `None`, или с помощью функции `_detect_most_popular_language`, если путь к файлу не задан. Если определённый язык программирования найден в словаре `LANGUAGE_MAPPING`, создаётся экземпляр класса `Parser` с соответствующим языком программирования. В противном случае атрибуты `self.ts_language` и `self.parser` устанавливаются равными `None`.

Также в функции устанавливаются атрибуты `self.code` и `self.root` равными `None`.

**Примечание**: При использовании функции `__init__` следует учитывать, что определение языка программирования осуществляется на основе расширения файла или наиболее популярного языка в репозитории. Если файл имеет нестандартное расширение или расширение не указано в словаре `EXTENSION_TO_LANGUAGE`, функция `_detect_language` может вернуть неверный результат. В случае отсутствия поддерживаемых языков в репозитории или при возникновении ошибки функция `_detect_most_popular_language` может вернуть Python по умолчанию.
***
### FunctionDef _detect_language(self, file_path)
**_detect_language_**: Функция _detect_language определяет язык программирования по расширению файла.

**parameters**:
- параметр 1: `file_path` — путь к файлу.

**Описание кода**:
Функция _detect_language принимает путь к файлу и определяет язык программирования на основе расширения файла. Для этого используется словарь EXTENSION_TO_LANGUAGE, где ключами являются расширения файлов, а значениями — соответствующие языки программирования. Функция возвращает значение из словаря, соответствующее расширению файла.

Эта функция вызывается в конструкторе `__init__` класса `FileHandler`, чтобы определить язык программирования для заданного файла. Если путь к файлу не задан, функция `_detect_most_popular_language` определяет наиболее популярный язык в репозитории.

Также функция _detect_language используется в методе `generate_file_structure` для определения языка файла перед генерацией структуры файла. Если язык файла не найден в словаре `LANGUAGE_MAPPING`, используется базовый разбор файла.

**Примечание**:
При использовании функции _detect_language необходимо учитывать, что она определяет язык только на основе расширения файла. Если файл имеет нестандартное расширение или расширение не указано в словаре EXTENSION_TO_LANGUAGE, функция может вернуть неверный результат.

**Пример вывода**:
```
detect_language("example.py")  # Вернёт "python"
```
***
### FunctionDef _detect_most_popular_language(self)
**_detect_most_popular_language_**: Функция _detect_most_popular_language определяет наиболее популярный язык программирования в репозитории.

**parameters**:
- параметр 1: нет принимаемых параметров

**Описание кода**: Функция _detect_most_popular_language использует объект GitignoreChecker для проверки файлов и папок в репозитории и определения языка программирования каждого файла с помощью функции _detect_language. Затем она подсчитывает количество файлов для каждого языка с помощью объекта Counter и возвращает наиболее популярный язык. Если в репозитории нет поддерживаемых языков, возвращается Python по умолчанию.

Функция вызывается в случае, если путь к файлу не задан в конструкторе __init__ класса FileHandler. Она также используется для определения наиболее популярного языка в репозитории при отсутствии конкретного пути к файлу.

В случае возникновения ошибки при определении наиболее популярного языка возвращается Python по умолчанию.

**Примечание**: При использовании функции _detect_most_popular_language следует учитывать, что она может возвращать Python по умолчанию в случае отсутствия поддерживаемых языков в репозитории или при возникновении ошибки.

**Пример вывода**:
```
Detected most popular language in repository: python
```
***
### FunctionDef read_file(self, file_path)
**read_file**: Функция read_file предназначена для чтения содержимого файла.

**parameters**:
- параметр 1: file_path — путь к файлу, который нужно прочитать. Этот параметр является опциональным.

**Описание кода**:
Функция read_file считывает содержимое файла по указанному пути. Если путь к файлу не задан (file_path равен None), используется путь к файлу, сохранённый в атрибуте self.file_path объекта. Если ни один из путей не задан и не может быть использован, функция вызывает исключение ValueError. Затем формируется абсолютный путь к файлу с помощью модуля os, и файл открывается в режиме чтения с кодировкой utf-8. Содержимое файла считывается и возвращается в виде строки.

**Примечание**:
При использовании функции необходимо убедиться, что указан корректный путь к файлу или настроен атрибут self.file_path. В противном случае будет вызвано исключение ValueError.

**Пример вывода**:
Вызов функции read_file с корректным путём к файлу вернёт содержимое этого файла в виде строки.
***
### FunctionDef write_file(self, file_path, content)
**write_file**: Функция write_file предназначена для записи содержимого в файл.

**parameters**:
* параметр 1: `file_path` — путь к файлу, в который будет записано содержимое.
* параметр 2: `content` — содержимое, которое будет записано в файл.

**Описание кода**:
Функция `write_file` принимает два параметра: `file_path` и `content`. Параметр `file_path` указывает на путь к файлу, в который будет записано содержимое. Если путь начинается с символа `/`, то этот символ удаляется. Затем формируется абсолютный путь к файлу с использованием `repo_path` и `file_path`.

Создаётся директория, в которой будет находиться файл, если она ещё не существует. После этого файл открывается в режиме записи (`"w"`) с кодировкой `utf-8`, и содержимое записывается в файл.

**Примечание**:
При использовании функции `write_file` убедитесь, что путь к файлу (`file_path`) указан корректно и что директория, в которой будет находиться файл, существует или может быть создана.
***
### FunctionDef get_modified_file_versions(self, file_path)
**get_modified_file_versions**: Функция `get_modified_file_versions` получает текущую и предыдущую версии файла из git.

**parameters**:
* параметр 1: `file_path` — путь к файлу, для которого нужно получить версии. Если не указан, используется значение `self.file_path`.

**Описание кода**: Функция `get_modified_file_versions` сначала проверяет наличие пути к файлу. Если путь не задан и не определён в атрибуте `self.file_path`, возникает ошибка `ValueError`. Затем создаётся объект `repo` с помощью `git.Repo`, который указывает на директорию репозитория, связанную с объектом.

Текущая версия файла считывается из указанного пути в репозитории. Предыдущая версия файла получается из последнего коммита, связанного с файлом. Если коммиты отсутствуют, предыдущая версия устанавливается как `None`.

Функция возвращает кортеж, содержащий текущую и предыдущую версии файла.

**Примечание**: Для корректной работы функции необходимо, чтобы директория репозитория была доступна и правильно настроена. Также важно учитывать, что функция работает с файлами в репозитории git и может не подойти для других систем контроля версий.

**Пример вывода**:
```
(current_version, previous_version) = get_modified_file_versions(file_path)
```
***
### FunctionDef parse_code(self)
**parse_code**: Функция parse_code предназначена для анализа кода с использованием библиотеки Tree-sitter.

**parameters**:
- параметр 1: `code` — строка с кодом, который нужно проанализировать.

**Описание кода**: Функция parse_code использует предварительно инициализированный парсер для анализа переданного кода. Сначала проверяется наличие парсера, если он отсутствует, возвращается `None`. Затем код преобразуется в UTF-8 и передаётся на парсинг. В результате получается дерево (tree), которое сохраняется в корне объекта.

Функция вызывается объектом, который работает с файлами в репозитории и использует методы для получения версий файлов. Это позволяет анализировать изменения в файлах и генерировать соответствующие структуры дерева.

**Примечание**: При использовании функции parse_code важно убедиться, что парсер (`self.parser`) правильно инициализирован и доступен для выполнения анализа кода.

**Пример вывода**: Результат работы функции — корневой узел дерева (root), который представляет собой структуру данных, отражающую синтаксическую иерархию проанализированного кода.
***
### FunctionDef parse_file(self)
**parse_file**: Функция parse_file предназначена для анализа файла с использованием библиотеки Tree-sitter.

**parameters**:
- параметр 1: `filename` — строка с именем файла, который нужно проанализировать.

**Описание кода**: Функция parse_file открывает указанный файл и считывает его содержимое в кодировке UTF-8. Затем она вызывает функцию parse_code для анализа считанного кода.

Функция используется в контексте работы с файлами в репозитории. Она позволяет анализировать файлы и генерировать соответствующие структуры дерева.

Для работы функции необходимо, чтобы объект FileHandler имел правильно инициализированный путь к репозиторию (`repo_path`).

Функция parse_file вызывается функцией generate_file_structure, которая создаёт структуру файла на основе его содержимого.

**Примечание**: При использовании функции parse_file важно убедиться, что объект FileHandler имеет правильно установленный путь к репозиторию.

**Пример вывода**: Функция возвращает корневой узел дерева (root), который представляет собой структуру данных, отражающую синтаксическую иерархию проанализированного кода.
***
### FunctionDef get_node_text(self, node)
**get_node_text**: Функция `get_node_text` извлекает текстовое содержимое узла.

**parameters**:
- параметр 1: `node` — узел, для которого извлекается текст.

**Описание кода**: Функция `get_node_text` возвращает текстовое содержимое узла, используя его начальные и конечные байты для определения диапазона текста в кодировке UTF-8. Если `self.code` не определено, возвращается пустая строка.

Функция `get_node_text` вызывается в следующих ситуациях:
- `FileHandler._extract_name_from_function_definition` извлекает имя из узла `function_definition`.
- `FileHandler._extract_name_generic` извлекает имя из узлов, не являющихся узлами функций.
- `FileHandler._extract_go_function_name` извлекает имя функции или метода в языке Go.

**Примечание**: Обратите внимание, что функция `get_node_text` используется для извлечения текста из узлов в различных контекстах, и её корректное использование важно для правильного извлечения информации из кода.

**Пример вывода**: `get_node_text` может вернуть строку, содержащую текст внутри узла, например, имя функции или метода.
***
### FunctionDef extract_name(self, node)
**extract_name**: Функция `extract_name` предназначена для извлечения имени из узла, обрабатывая при этом декорированные функции.

**parameters**:
* параметр 1: `node` — узел, из которого извлекается имя.

**Описание кода**: Функция `extract_name` анализирует тип узла и в зависимости от этого вызывает соответствующие функции для извлечения имени. Если узел является `decorated_definition`, то функция ищет внутри него `function_definition` и вызывает `_extract_name_from_function_definition` для этого дочернего элемента. Если узел является `function_definition`, то `_extract_name_from_function_definition` вызывается непосредственно для этого узла. Для других типов узлов вызывается `_extract_name_generic`.

Функция `extract_name` используется в ситуациях, когда необходимо извлечь имя из различных типов узлов, включая декорированные определения и определения функций. Это может быть полезно при анализе кода, который содержит декорированные функции или другие элементы. Функция `extract_name` вызывается другими функциями, которые работают с узлами, представляющими различные элементы кода.

**Примечание**: Обратите внимание, что корректное использование функции `_extract_name_from_function_definition` и `_extract_name_generic` важно для правильного извлечения имён функций из кода.

**Пример вывода**: Функция может вернуть строку, содержащую имя функции, например, `unknown` в случае, если имя не было найдено.
***
### FunctionDef _extract_name_from_function_definition(self, node)
**_extract_name_from_function_definition_**: Функция `_extract_name_from_function_definition` извлекает имя, конкретно из узла `function_definition`.

**parameters**:
- параметр 1: `node` — узел, для которого извлекается имя.

**Описание кода**: Функция `_extract_name_from_function_definition` перебирает дочерние элементы узла `node`. Если среди дочерних элементов находится элемент типа `identifier`, то возвращается текстовое содержимое этого элемента. В противном случае возвращается строка `unknown`.

Функция `_extract_name_from_function_definition` вызывается из функции `extract_name`, которая обрабатывает различные типы узлов, включая `decorated_definition` и `function_definition`. Если узел является `decorated_definition`, то функция ищет внутри него `function_definition` и вызывает `_extract_name_from_function_definition` для этого дочернего элемента. Если узел является `function_definition`, то `_extract_name_from_function_definition` вызывается непосредственно для этого узла. Для других типов узлов вызывается `_extract_name_generic`.

**Примечание**: Обратите внимание, что корректное использование функции `_extract_name_from_function_definition` важно для правильного извлечения имён функций из кода.

**Пример вывода**: Функция может вернуть строку, содержащую имя функции, например, `unknown` в случае, если имя не было найдено.
***
### FunctionDef _extract_name_generic(self, node)
**_extract_name_generic_**: Функция _extract_name_generic предназначена для извлечения общего имени из узлов, которые не являются узлами функций.

**parameters**:
* параметр 1: `node` — узел, из которого извлекается имя.

**Описание кода**: Функция _extract_name_generic анализирует узел и извлекает из него имя. Если узел представляет собой объявление метода или функции на языке Go, функция _extract_name_generic вызывает _extract_go_function_name для извлечения имени. В противном случае функция ищет в узле идентификатор или имя и возвращает его текстовое содержимое. Если имя не найдено, возвращается значение "unknown".

Функция _extract_name_generic вызывается в ситуациях, когда необходимо извлечь имя из узлов, не являющихся узлами функций. Это может быть полезно при анализе кода, который содержит объявления классов, методов и других элементов, не являющихся функциями. Функция _extract_name_generic используется в контексте анализа кода и может быть вызвана другими функциями, которые работают с узлами, представляющими различные элементы кода.

Функция _extract_name_generic вызывается из функции extract_name, которая предназначена для извлечения имени из узла, обрабатывая при этом декорированные функции. Если узел представляет собой декорированное определение в Python, extract_name вызывает _extract_name_from_function_definition для извлечения имени из определения функции. В противном случае extract_name вызывает _extract_name_generic для извлечения имени из узла.

**Примечание**: Обратите внимание, что функция _extract_name_generic корректно обрабатывает различные типы узлов и извлекает из них соответствующие имена. Это важно для правильного анализа кода и извлечения из него необходимой информации.

**Пример вывода**: Функция может вернуть строку, содержащую имя, например, имя переменной или класса.
***
### FunctionDef _extract_go_function_name(self, node)
**_extract_go_function_name**: Функция _extract_go_function_name предназначена для извлечения имени функции или метода в языке Go.

**parameters**:
- параметр 1: `node` — узел, для которого извлекается имя функции или метода.

**Описание кода**: Функция _extract_go_function_name анализирует узел и ищет в нём имя функции или метода в соответствии с синтаксисом языка Go. Она проверяет, является ли найденный идентификатор именем функции (не являющимся частью получателя) или именем метода (с указанием получателя). Если имя найдено, оно возвращается. В противном случае возвращается значение "unknown".

Функция вызывается в ситуациях, когда необходимо извлечь имя функции или метода в языке Go. Она используется в контексте анализа кода и может быть вызвана другими функциями, которые работают с узлами, представляющими функции или методы.

Функция _extract_go_function_name вызывается из функции _extract_name_generic, которая предназначена для извлечения имени из узлов, не являющихся узлами функций. Если узел представляет собой объявление метода или функции в языке Go, _extract_name_generic вызывает _extract_go_function_name для извлечения имени.

**Примечание**: Обратите внимание, что функция _extract_go_function_name корректно обрабатывает случаи, когда имя функции или метода следует после списка параметров или является единственным идентификатором в узле. Это важно для правильного извлечения информации из кода на языке Go.

**Пример вывода**: Функция может вернуть строку, содержащую имя функции или метода, например, "func Name(params)".
***
### FunctionDef extract_parameters(self, node)
**extract_parameters**: Функция `extract_parameters` имеет значение извлечения параметров из узла функции или метода в зависимости от языка программирования.

**parameters**:
* параметр 1: `node` — узел, для которого извлекаются параметры.

**Описание кода**: Функция `extract_parameters` определяет язык программирования и вызывает соответствующую функцию для извлечения параметров. В зависимости от языка программирования (`python`, `java`, `go`, `kotlin`) вызываются разные функции: `_extract_python_parameters`, `_extract_java_parameters`, `_extract_go_parameters`, `_extract_kotlin_parameters`. Если язык программирования не определён, возвращается пустой список.

Функция `extract_parameters` используется в контексте обработки узлов, представляющих функции или методы в различных языках программирования. Она вызывается из функции `get_functions_and_classes`, которая извлекает функции и классы из проанализированного кода.

**Примечание**: Обратите внимание, что корректная работа функции `extract_parameters` зависит от правильной структуры узла и корректного использования функции `get_node_text` для извлечения текстового содержимого узлов.

**Пример вывода**: Функция может вернуть список параметров, например, `["param1", "param2"]`.
***
### FunctionDef _extract_python_parameters(self, node)
**_extract_python_parameters**: Функция _extract_python_parameters извлекает параметры для функций Python.

**parameters**:
* параметр 1: `node` — узел, для которого извлекаются параметры.

**Описание кода**: Функция _extract_python_parameters анализирует узел и извлекает параметры функции Python. Если узел является декорированным определением функции, функция рекурсивно вызывает себя для дочернего узла, представляющего определение функции. В случае обычного определения функции, она перебирает дочерние узлы в поисках параметров. Для каждого параметра, представленного идентификатором, добавляется его текстовое содержимое в список `params`. Если параметр имеет значение по умолчанию, функция извлекает имя параметра из дочернего узла с помощью функции `get_node_text`.

Функция вызывается в методе `extract_parameters`, который определяет язык программирования и вызывает соответствующую функцию для извлечения параметров.

**Примечание**: Обратите внимание, что корректная работа функции _extract_python_parameters зависит от правильной структуры узла и корректного использования функции `get_node_text` для извлечения текстового содержимого узлов.

**Пример вывода**: Функция может вернуть список параметров, например, `["param1", "param2"]`.
***
### FunctionDef _extract_java_parameters(self, node)
**_extract_java_parameters**: Функция _extract_java_parameters извлекает параметры для методов Java.

**parameters**:
- параметр 1: `node` — узел, для которого извлекаются параметры.

**Описание кода**: Функция _extract_java_parameters проходит по дочерним элементам узла `node` и ищет элементы типа `formal_parameters`. Затем она перебирает дочерние элементы этого типа и извлекает имена параметров, которые хранятся в виде идентификаторов. Если в `formal_parameter` есть хотя бы один идентификатор, его текстовое содержимое добавляется в список `params`. В итоге возвращается список извлечённых параметров или пустой список, если параметры не найдены.

Функция _extract_java_parameters вызывается из функции `extract_parameters`, которая определяет язык программирования и вызывает соответствующую функцию для извлечения параметров. Эта функция вызывается в контексте обработки узлов, представляющих функции или методы в различных языках программирования, таких как Java.

**Примечание**: Обратите внимание, что корректное использование функции _extract_java_parameters важно для правильного извлечения параметров методов Java из исходного кода.

**Пример вывода**: Функция может вернуть список, содержащий имена параметров метода Java, например, ["parameter1", "parameter2"].
***
### FunctionDef _extract_go_parameters(self, node)
**_extract_go_parameters**: Функция _extract_go_parameters извлекает параметры для функций на языке Go.

**parameters**:
- параметр 1: `node` — узел, из которого извлекаются параметры.

**Описание кода**: Функция _extract_go_parameters обходит дерево синтаксического разбора и ищет в нём список параметров функции. Для этого она перебирает все дочерние элементы узла `node` и ищет среди них элемент типа `parameter_list`. Затем функция обходит все дочерние элементы этого списка и ищет среди них объявления параметров (`parameter_declaration`). Для каждого объявления параметров функция извлекает имена параметров, обходя его дочерние элементы и ища среди них идентификаторы (`identifier`). Извлечённые имена параметров добавляются в список `params`, который затем возвращается в качестве результата функции. Если список параметров не найден, функция возвращает пустой список.

Функция _extract_go_parameters вызывается из функции `extract_parameters`, которая определяет, какую функцию извлечения параметров вызывать в зависимости от языка программирования.

**Примечание**: Обратите внимание, что корректная работа функции _extract_go_parameters зависит от корректного построения дерева синтаксического разбора исходного кода.

**Пример вывода**: Функция может вернуть список строк, содержащих имена параметров функции на языке Go.
***
### FunctionDef _extract_kotlin_parameters(self, node)
**_extract_kotlin_parameters**: Функция `_extract_kotlin_parameters` извлекает параметры для функций на языке Kotlin.

**parameters**:
- параметр 1: `node` — узел, для которого извлекаются параметры.

**Описание кода**: Функция `_extract_kotlin_parameters` проходит по дочерним элементам узла `node` и ищет элементы типа `function_value_parameters`. Затем она собирает имена параметров в список `params`, извлекая их из дочерних элементов типа `function_value_parameter` и `simple_identifier`. Если в узле `node` не найдены подходящие параметры, функция возвращает пустой список.

Функция `_extract_kotlin_parameters` вызывается из функции `extract_parameters`, которая выбирает соответствующую функцию для извлечения параметров в зависимости от языка программирования. Если язык программирования — Kotlin, вызывается `_extract_kotlin_parameters`.

**Примечание**: Обратите внимание, что функция `_extract_kotlin_parameters` корректно извлекает параметры только в случае, если структура узла соответствует ожидаемой. Если структура узла отличается, функция может не вернуть корректные результаты.

**Пример вывода**: Функция `_extract_kotlin_parameters` может вернуть список строк, содержащих имена параметров функции на Kotlin.
***
### FunctionDef get_functions_and_classes(self)
**get_functions_and_classes**: Функция `get_functions_and_classes` извлекает из проанализированного кода функции и классы.

**parameters**:
* параметр 1: нет

**Описание кода**: Функция `get_functions_and_classes` анализирует дерево синтаксического разбора кода и извлекает из него информацию о функциях и классах. Для этого она использует вспомогательную функцию `walk`, которая рекурсивно обходит все узлы дерева. В зависимости от типа узла (`function` или `class`) функция `get_functions_and_classes` добавляет в результирующий список информацию о найденной функции или классе. Функция `get_functions_and_classes` вызывается из функции `generate_file_structure`, которая генерирует структуру файла на основе его содержимого.

Для извлечения имени функции или класса используется функция `extract_name`, которая анализирует тип узла и в зависимости от этого вызывает соответствующие функции для извлечения имени. Для извлечения параметров функции используется функция `extract_parameters`, которая определяет язык программирования и вызывает соответствующую функцию для извлечения параметров.

Функция `get_functions_and_classes` возвращает список кортежей, каждый из которых содержит информацию о функции или классе: тип (`FunctionDef` для Python или `Function` для других языков, `ClassDef` для Python или `Class` для других языков), имя, номера строк начала и конца, параметры, родительский элемент и текстовое содержимое.

**Примечание**: Обратите внимание, что корректное использование функций `extract_name` и `extract_parameters` важно для правильного извлечения информации о функциях и классах из кода.

**Пример вывода**: `[("FunctionDef", "func_name", 10, 20, ["param1", "param2"], None, "def func_name(param1, param2): ..."), ("ClassDef", "ClassName", 25, 35, [], None, "class ClassName: ...")]`
***
### FunctionDef get_obj_code_info(self, code_type, code_name, start_line, end_line, params, file_path)
**get_obj_code_info**: Функция get_obj_code_info предназначена для получения подробной информации о коде объекта.

**parameters**:
- параметр 1: `code_type` — тип кода объекта;
- параметр 2: `code_name` — имя кода объекта;
- параметр 3: `start_line` — номер начальной строки кода;
- параметр 4: `end_line` — номер конечной строки кода;
- параметр 5: `params` — параметры кода;
- параметр 6: `file_path` (опционально) — путь к файлу, в котором находится код (по умолчанию используется путь, установленный в экземпляре объекта).

**Описание кода**:
Функция `get_obj_code_info` получает информацию о коде объекта, включая его тип, имя, параметры, начальную и конечную строки в файле, а также содержание кода. Она открывает указанный файл и считывает строки, соответствующие заданному диапазону. Затем функция ищет имя кода в этих строках и определяет, есть ли в коде оператор `return`.

Функция использует следующие шаги:
1. Инициализирует словарь `code_info` для хранения информации о коде.
2. Заполняет словарь значениями параметров функции.
3. Определяет путь к файлу для чтения.
4. Открывает файл и считывает его содержимое.
5. Извлекает содержание кода, соответствующее заданному диапазону строк.
6. Определяет позицию имени кода в первой строке диапазона.
7. Проверяет наличие оператора `return` в содержимом кода.
8. Заполняет словарь `code_info` найденной информацией.
9. Возвращает словарь `code_info`.

Функция может быть вызвана из других частей программы, например, для получения информации о функциях и классах в файле.

**Примечание**:
При вызове функции необходимо указать путь к файлу, если он не был установлен ранее в экземпляре объекта. В противном случае будет вызвано исключение `ValueError`.

**Пример вывода**:
```
{
    "type": "функция",
    "name": "example_function",
    "md_content": [],
    "code_start_line": 10,
    "code_end_line": 20,
    "params": ["параметр1", "параметр2"],
    "have_return": True,
    "code_content": "content of the function",
    "name_column": 10
}
```
***
### FunctionDef generate_file_structure(self, file_path)
**generate_file_structure**: Функция generate_file_structure создаёт структуру для отдельного файла.

**parameters**:
* параметр 1: `file_path` — путь к файлу.

**Описание кода**: Функция generate_file_structure анализирует файл и создаёт его структуру. Сначала она определяет язык программирования файла с помощью функции _detect_language. Если язык не определён или не поддерживается, используется базовый разбор файла. Затем функция parse_file анализирует файл с использованием библиотеки Tree-sitter. После этого функция get_functions_and_classes извлекает из проанализированного кода функции и классы. Затем создаётся список file_objects, в который добавляются объекты кода (функции и классы) в виде кортежей с информацией о них.

Функция generate_file_structure вызывается из функции generate_overall_structure, которая создаёт структуру для всего репозитория.

Функция generate_file_structure временно изменяет язык программирования, если он отличается от текущего, чтобы использовать соответствующий парсер. После создания структуры файла язык программирования и парсер восстанавливаются до исходных значений.

**Примечание**: При использовании функции generate_file_structure необходимо убедиться, что путь к файлу указан корректно. Если путь не задан, функция _detect_language попытается определить наиболее популярный язык в репозитории, что может привести к некорректным результатам.

**Пример вывода**: Список file_objects, содержащий кортежи с информацией о функциях и классах в файле.
***
### FunctionDef _fallback_file_structure(self, file_path)
**_fallback_file_structure**: Функция _fallback_file_structure используется для обработки файлов с неподдерживаемыми типами и возвращает пустую структуру.

**parameters**:
- параметр 1: `file_path` — путь к файлу, для которого нужно сгенерировать структуру.

**Описание кода**:
Функция _fallback_file_structure вызывается, когда не удаётся определить язык файла или когда файл имеет неподдерживаемый тип. В таких случаях функция возвращает пустой список, что означает отсутствие структуры для файла. Это обеспечивает согласованное поведение при работе с файлами, для которых не предусмотрен специальный обработчик.

Функция _generate_file_structure определяет, что файл не поддерживается, и вызывает _fallback_file_structure для обработки такого файла.

**Примечание**:
При работе с файлами, для которых не предусмотрен специальный обработчик, важно корректно обрабатывать такие ситуации, чтобы избежать ошибок и неожиданного поведения программы. Функция _fallback_file_structure обеспечивает единый подход к обработке файлов с неподдерживаемыми типами.

**Пример вывода**:
```
[]
```
***
### FunctionDef generate_overall_structure(self, file_path_reflections, jump_files)
**generate_overall_structure**: Функция generate_overall_structure создаёт структуру для всего репозитория.

**parameters**:
* параметр 1: `file_path_reflections` — список путей к файлам и отражениям, которые необходимо учесть при создании структуры репозитория;
* параметр 2: `jump_files` — список файлов, которые нужно игнорировать при создании структуры.

**Описание кода**: Функция generate_overall_structure проходит по всем файлам и папкам в репозитории, исключая те, которые указаны в .gitignore, а также те, которые находятся в списке jump_files. Для каждого файла, который не был проигнорирован, функция вызывает generate_file_structure для создания структуры файла. Затем эта структура добавляется в словарь repo_structure. Если при создании структуры файла возникает ошибка, она регистрируется в логере, и процесс продолжается со следующим файлом.

Функция использует объект GitignoreChecker для проверки файлов и папок в соответствии с правилами, указанными в .gitignore. Для отображения прогресса используется библиотека tqdm.

**Примечание**: При использовании функции generate_overall_structure необходимо убедиться, что параметры file_path_reflections и jump_files указаны корректно. Также важно учитывать, что функция может игнорировать файлы и папки, указанные в .gitignore, и файлы из списка jump_files.

**Пример вывода**: Словарь repo_structure, содержащий структуры для всех файлов и папок в репозитории, за исключением игнорируемых файлов и папок.
***
### FunctionDef convert_to_markdown_file(self, file_path)
**convert_to_markdown_file**: Функция convert_to_markdown_file преобразует структуру файла в формат Markdown.

**parameters**:
- параметр `file_path`: путь к файлу.

**Описание кода**:
Функция `convert_to_markdown_file` принимает на вход путь к файлу (`file_path`) и преобразует структуру файла, представленную в формате JSON, в формат Markdown. Если путь к файлу не указан, используется путь по умолчанию (`self.file_path`).

Если данные в JSON представляют собой список, они преобразуются в формат словаря для совместимости. Затем объекты файла сортируются по номеру строки начала кода. Для каждого объекта определяется уровень вложенности, и на основе этого формируется структура Markdown.

Функция обрабатывает объекты с типом `FunctionDef`, `AsyncFunctionDef` и `Function`, добавляя параметры в формате, соответствующем синтаксису Python.

**Примечание**:
При использовании функции необходимо убедиться, что путь к файлу указан корректно, иначе будет вызвано исключение `ValueError`. Также важно учесть, что функция предполагает наличие определённой структуры данных в JSON-файле.

**Пример вывода**:
Пример вывода зависит от структуры данных в JSON-файле и может представлять собой многоуровневый список с заголовками и содержимым в формате Markdown.
***
