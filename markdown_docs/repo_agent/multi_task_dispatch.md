## ClassDef Task
**Task**: Функция Task представляет собой класс, предназначенный для описания отдельной задачи в системе многозадачного диспетчера.

**attributes**:
* параметр 1: `task_id` — уникальный идентификатор задачи (тип данных: `int`).
* параметр 2: `dependencies` — список зависимостей задачи (тип данных: `List[Task]`).
* параметр 3: `extra_info` — дополнительная информация о задаче (тип данных: `Any`).
* параметр 4: `status` — статус выполнения задачи (тип данных: `int`, начальное значение: `0`).

**Описание кода**:
Класс `Task` представляет собой задачу в системе многозадачного диспетчера. Конструктор класса `Task` принимает три параметра: `task_id`, `dependencies` и `extra_info`. `task_id` — уникальный идентификатор задачи. `dependencies` — список объектов `Task`, которые являются зависимостями текущей задачи. `extra_info` — дополнительная информация о задаче.

При создании объекта `Task` его статус устанавливается в `0`, что означает, что задача ещё не начата.

Класс `Task` используется в системе многозадачного диспетчера, где задачи могут иметь зависимости друг от друга. Класс `TaskManager` управляет задачами и их зависимостями. Метод `add_task` класса `TaskManager` создаёт новую задачу и добавляет её в словарь `task_dict`.

**Примечание**:
При создании задачи необходимо убедиться, что `task_id` является уникальным. Также необходимо правильно установить зависимости задачи, чтобы система могла корректно управлять выполнением задач.
### FunctionDef __init__(self)
**__init__**: Функция __init__ инициализирует объект класса Task.

**parameters**:
- параметр 1: `task_id` — уникальный идентификатор задачи (целое число).
- параметр 2: `dependencies` — список объектов класса Task, представляющих зависимости текущей задачи.
- параметр 3: `extra_info` — дополнительная информация о задаче (может быть любого типа данных).

**Описание кода**:
Функция __init__ принимает три параметра и инициализирует соответствующие атрибуты объекта класса Task. Атрибут `task_id` получает значение параметра `task_id`. Атрибут `extra_info` получает значение параметра `extra_info`. Атрибут `dependencies` получает значение параметра `dependencies`. Атрибут `status` инициализируется значением 0.

**Примечание**:
При создании нового объекта класса Task необходимо указать уникальный идентификатор `task_id`. Список `dependencies` может быть пустым, если у задачи нет зависимостей. Значение `extra_info` может быть любым, но не обязательно.
***
## ClassDef TaskManager
**TaskManager**: Функция TaskManager предназначена для управления задачами, их добавления, отслеживания зависимостей и статуса выполнения.

**Attributes**:
- параметр 1: `task_dict` — словарь, где ключи — это идентификаторы задач, а значения — объекты типа `Task`.
- параметр 2: `now_id` — текущий идентификатор задачи.
- параметр 3: `query_id` — идентификатор запроса для отслеживания.

**Описание кода**:

Класс `TaskManager` предназначен для централизованного управления задачами и их зависимостями. В конструкторе (`__init__`) инициализируются пустой словарь `task_dict` для хранения задач, счётчики `now_id` и `query_id`.

Метод `all_success` возвращает `True`, если все задачи выполнены (`len(task_dict) == 0`), и `False` в противном случае.

Метод `add_task` добавляет новую задачу в словарь `task_dict`, устанавливая её идентификатор `now_id`, зависимости и дополнительную информацию. Параметр `dependency_task_id` содержит список идентификаторов зависимостей новой задачи.

Метод `get_next_task` находит и возвращает первую готовую задачу (`status == 0` и отсутствуют зависимости), помечает её как выполненную (`status = 1`) и увеличивает `query_id`.

Метод `mark_completed` удаляет завершённую задачу из словаря `task_dict` и обновляет зависимости других задач, удаляя из них завершённую задачу.

**Примечание**:
При использовании `add_task` необходимо передавать корректный список `dependency_task_id` для корректного установления зависимостей.

**Пример вывода**:

Использование класса `TaskManager` может выглядеть следующим образом:
```
manager = TaskManager()
task_id = manager.add_task([1, 2])
task, task_id = manager.get_next_task()
manager.mark_completed(task_id)
```
### FunctionDef __init__(self)
**__init__**: Функция `__init__` имеет значение инициализации объекта класса `TaskManager`.

**parameters**:
- параметр 1: нет

**Описание кода**:
Функция `__init__` используется для инициализации объекта класса `TaskManager`. В процессе инициализации создаются следующие атрибуты:
- `self.task_dict`: словарь, где ключи — уникальные идентификаторы задач (`int`), а значения — объекты класса `Task`.
- `self.now_id`: переменная для хранения текущего уникального идентификатора задачи.
- `self.query_id`: переменная для хранения идентификатора запроса.

**Примечание**:
При создании объекта `TaskManager` все атрибуты инициализируются с нулевыми значениями. Важно понимать, что `self.task_dict` будет использоваться для хранения задач и их зависимостей, а `self.now_id` и `self.query_id` — для управления идентификаторами задач и запросов.
***
### FunctionDef all_success(self)
**all_success**: Функция all_success имеет значение True, если словарь tasks (self.task_dict) пуст, то есть если все задачи были успешно выполнены.

**parameters**: нет параметров.

**Описание кода**: Функция all_success возвращает логическое значение, которое указывает на успешное завершение всех задач. Она проверяет, что длина словаря self.task_dict равна нулю, что означает отсутствие незавершённых задач.

**Примечание**: Функция all_success может быть полезна для проверки состояния выполнения задач в системе управления задачами. Она может использоваться в различных частях системы для принятия решений на основе успешности выполнения задач.

**Пример вывода**: True или False в зависимости от состояния выполнения задач.
***
### FunctionDef add_task(self, extra)
**add_task**: Функция `add_task` добавляет новую задачу в систему многозадачного диспетчера, присваивая ей уникальный идентификатор и устанавливая зависимости.

**parameters**:
* параметр 1: `dependency_task_id` — список уникальных идентификаторов задач, которые являются зависимостями новой задачи (тип данных: `List[int]`).
* параметр 2: `extra` — дополнительная информация о новой задаче (тип данных: `Any`).

**Описание кода**:
Метод `add_task` класса `TaskManager` создаёт новую задачу и добавляет её в словарь `task_dict`. Для этого он выполняет следующие шаги:
1. Создаёт список `depend_tasks`, содержащий объекты `Task`, соответствующие идентификаторам из `dependency_task_id`.
2. Создаёт новый объект `Task` с уникальным идентификатором `self.now_id`, зависимостями `depend_tasks` и дополнительной информацией `extra`.
3. Увеличивает значение `self.now_id` на `1`.
4. Возвращает идентификатор `self.now_id - 1` в качестве результата.

**Примечание**:
При использовании метода `add_task` необходимо убедиться, что `task_id` является уникальным. Также важно правильно установить зависимости задачи, чтобы система могла корректно управлять выполнением задач.

**Пример вывода**:
Результат выполнения функции — уникальный идентификатор добавленной задачи.
***
### FunctionDef get_next_task(self)
**get_next_task**: Функция get_next_task выбирает следующую задачу для выполнения из списка доступных задач.

**parameters**:
- параметр не указан.

**Описание кода**:
Функция get_next_task увеличивает значение query_id и последовательно проверяет статус каждой задачи в словаре self.task_dict. Если задача готова к выполнению (её зависимости отсутствуют и статус равен 0), её статус устанавливается в 1, выводится соответствующее сообщение и возвращается выбранная задача вместе с её идентификатором. Если готовых задач нет, возвращается None и -1.

Функция вызывается в цикле while в функции worker, которая обрабатывает задачи с помощью переданного хендлера handler и отмечает завершённые задачи.

**Примечание**:
При отсутствии готовых задач функция может возвращать None, что может привести к переходу на следующую итерацию цикла в вызывающей функции worker, где происходит задержка с помощью time.sleep(0.5). Это обеспечивает более гибкое управление выполнением задач.

**Пример вывода**:
Вызов функции get_next_task может вернуть кортеж с задачей и её идентификатором, например:
```
(task, task_id)
```
или
```
(None, -1)
```
***
### FunctionDef mark_completed(self)
**mark_completed**: Функция mark_completed отмечает задачу с указанным идентификатором как завершённую и удаляет её из списка зависимостей других задач.

**parameters**:
* параметр 1: task_id (int) — идентификатор задачи, которую нужно отметить как завершённую.

**Описание кода**:
Функция mark_completed принимает идентификатор задачи и выполняет следующие действия:
1. Получает задачу с указанным идентификатором из словаря task_dict.
2. Проверяет, есть ли эта задача в списке зависимостей других задач.
3. Если задача есть в списке зависимостей, удаляет её оттуда.
4. Удаляет задачу с указанным идентификатором из словаря task_dict.

Функция используется в контексте многозадачного диспетчера, где задачи выполняются последовательно. Она позволяет отслеживать зависимости между задачами и корректно обрабатывать завершение задач.

**Примечание**:
При использовании функции mark_completed необходимо убедиться, что идентификатор задачи корректен и существует в словаре task_dict. Также следует учитывать зависимости задач и корректно обрабатывать их удаление из списка зависимостей.
***
## FunctionDef worker(task_manager)
**worker**: Функция worker выполняет обработку задач, полученных от менеджера задач, с помощью переданного хендлера и отмечает завершённые задачи.

**parameters**:
* параметр 1: task_manager (объект TaskManager) — менеджер задач, который используется для получения задач и отметки их как завершённых.
* параметр 2: handler (Callable) — функция-обработчик, которая вызывается для обработки каждой задачи.

**Описание кода**: функция worker работает в бесконечном цикле `while True`. Она получает следующую задачу с помощью метода `get_next_task` объекта `task_manager`. Если задача не найдена (`task is None`), происходит задержка с помощью `time.sleep(0.5)` и цикл продолжается. Если задача найдена, она обрабатывается с помощью функции `handler`, а затем отмечается как завершённая с помощью метода `mark_completed` объекта `task_manager`.

**Примечание**: при отсутствии готовых задач функция `get_next_task` может возвращать `None`, что приводит к переходу на следующую итерацию цикла в функции `worker` и задержке выполнения. Это обеспечивает более гибкое управление выполнением задач.

**Пример вывода**: функция worker продолжает обработку задач до тех пор, пока все задачи не будут успешно выполнены (`task_manager.all_success`).
## FunctionDef some_function
**some_function**: Функция `some_function` выполняет задержку выполнения на случайное время, не принимая никаких параметров.

**parameters**: параметры функции `some_function` отсутствуют.

**Описание кода**: функция `some_function` использует `time.sleep()`, чтобы приостановить выполнение программы на случайное время, которое определяется с помощью `random.random() * 3`. Это означает, что время задержки будет случайным числом в диапазоне от 0 до 3 секунд.

**Примечание**: обратите внимание, что функция `some_function` может использоваться для имитации задержек в работе программы, например, для моделирования времени отклика системы или для распределения нагрузки. Однако использование такой функции может повлиять на общую производительность приложения, поэтому её следует применять с учётом этого фактора.
