## FunctionDef replace_extension_to_md
**replace_extension_to_md**: Функция `replace_extension_to_md` изменяет расширение указанного файла на `.md`.

**parameters**:
* `file_path`: путь к файлу в виде строки.

**Описание кода**: Функция `replace_extension_to_md` принимает путь к файлу в виде строки и возвращает строку с изменённым путём, где расширение файла заменено на `.md`. Для этого используется объект `Path` из модуля `pathlib`, который позволяет удобно работать с путями к файлам и папкам. Метод `with_suffix()` этого объекта изменяет расширение файла, а метод `str()` преобразует изменённый путь обратно в строку.

Функция вызывается в контексте обработки файлов в проекте, где требуется преобразовать файлы в формат Markdown. Например, в функции `markdown_refresh` она используется для создания файлов Markdown на основе содержимого других файлов. В функции `add_new_item` она применяется для записи содержимого Markdown в соответствующий файл.

**Примечание**: При использовании функции `replace_extension_to_md` необходимо убедиться, что путь к файлу указан корректно и что операция изменения расширения не вызовет ошибок в дальнейшей обработке файлов.
## ClassDef Runner
**Runner**: Функция Runner отвечает за генерацию документации для проекта на основе его структуры и изменений в коде.

**Attributes**:
* параметр `setting`: хранит настройки проекта, полученные через SettingsManager.
* параметр `absolute_project_hierarchy_path`: путь к иерархии проекта.
* параметр `project_manager`: менеджер проекта, используемый для управления структурой проекта.
* параметр `change_detector`: детектор изменений в репозитории.
* параметр `chat_engine`: движок для генерации документации на основе ChatEngine.
* параметр `meta_info`: информация о метаданных проекта.
* параметр `runner_lock`: блокировка для управления доступом к коду.

**Описание кода**:

Класс `Runner` отвечает за обновление документации проекта. В конструкторе (`__init__`) класса происходит инициализация основных компонентов:
* получение настроек проекта через `SettingsManager`;
* определение пути к иерархии проекта;
* создание менеджера проекта (`ProjectManager`);
* создание детектора изменений (`ChangeDetector`);
* создание движка для генерации документации (`ChatEngine`);
* инициализация метаинформации (`MetaInfo`).

Метод `get_all_pys` используется для поиска всех файлов с расширениями `.py`, `.java`, `.go`, `.kt`, `.kts` в указанной директории.

Метод `generate_doc_for_a_single_item` генерирует документацию для отдельного элемента (`DocItem`). Он проверяет, нужно ли генерировать документацию для этого элемента, и если да, то вызывает метод `generate_doc` движка `ChatEngine` для создания документации.

Метод `first_generate` запускает процесс генерации документации. Он создаёт менеджер задач (`TaskManager`), который определяет, какие задачи нужно выполнить, и вызывает метод `generate_doc_for_a_single_item` для каждой задачи.

Метод `markdown_refresh` обновляет файлы Markdown с документацией. Он удаляет существующие файлы Markdown, создаёт новую папку для Markdown-файлов и записывает в неё содержимое файлов.

Метод `to_markdown` преобразует структуру проекта в формат Markdown.

Метод `git_commit` выполняет коммит изменений в Git.

Метод `run` запускает процесс обновления документации. Он обнаруживает изменения в файлах, обрабатывает их и обновляет документацию.

Метод `add_new_item` добавляет новые проекты в JSON-файл и генерирует соответствующую документацию.

Метод `process_file_changes` обрабатывает изменения в файлах. Он читает исходный код файла, определяет изменения в структуре и обновляет JSON-файл с информацией о структуре проекта.

Метод `update_existing_item` обновляет существующие проекты. Он находит новые объекты в файле, обновляет информацию о них в JSON-файле и генерирует документацию.

Метод `update_object` генерирует документацию для обновлённого объекта.

Метод `get_new_objects` находит добавленные и удалённые объекты в файле.

**Примечание**:
При использовании класса `Runner` необходимо учитывать, что он работает с файлами проекта и может изменять их. Поэтому важно обеспечить блокировку доступа к файлам во время работы класса.

**Пример вывода**:

Запуск метода `run` класса `Runner` приведёт к обновлению документации проекта в соответствии с изменениями в коде.
### FunctionDef __init__(self)
**__init__**: Функция `__init__` инициализирует объект класса `Runner`, настраивая основные компоненты и параметры.

**parameters**: нет параметров.

**Описание кода**:

Функция `__init__` выполняет несколько ключевых задач:

1. Получает настройки проекта через `SettingsManager`.
2. Определяет путь к иерархии проекта.
3. Инициализирует `ProjectManager`, `ChangeDetector` и `ChatEngine`.
4. Проверяет существование директории проекта. Если директория не существует, создаёт фиктивные файлы и инициализирует `MetaInfo`. В противном случае загружает `MetaInfo` из существующей директории.
5. Устанавливает блокировку (`threading.Lock`) для синхронизации доступа к общим ресурсам.

**Примечание**:

При использовании `Runner` важно учитывать, что `MetaInfo` будет инициализирован на основе существования директории проекта. Если директория не существует, будут созданы фиктивные файлы, что может повлиять на дальнейшее поведение системы. Также необходимо учитывать использование `threading.Lock` для предотвращения конфликтов при одновременном доступе к общим ресурсам.
***
### FunctionDef get_all_pys(self, directory)
**get_all_pys**: Функция `get_all_pys` предназначена для поиска и возврата списка всех файлов с расширениями .py, .java, .go, .kt, .kts в заданной директории и её поддиректориях.

**parameters**:
* параметр 1: `directory` — строка, представляющая путь к директории, в которой необходимо произвести поиск файлов.

**Описание кода**:
Функция `get_all_pys` использует метод `os.walk` для рекурсивного обхода директории и её поддиректорий. Для каждого файла в директории проверяется его расширение с помощью метода `endswith`. Если расширение файла соответствует одному из заданных (`".py", ".java", ".go", ".kt", ".kts"`), то путь к файлу добавляется в список `code_files`. В конце функция возвращает список `code_files`, содержащий все найденные файлы.

**Примечание**:
При использовании функции `get_all_pys` необходимо убедиться, что путь к директории (`directory`) указан корректно, иначе функция может не найти нужные файлы или выдать ошибку.

**Пример вывода**:
`["./path/to/directory/file1.py", "./path/to/directory/subdir/file2.java", ...]`
***
### FunctionDef generate_doc_for_a_single_item(self)
**generate_doc_for_a_single_item**: Функция generate_doc_for_a_single_item генерирует документацию для отдельного элемента проекта.

**parameters**:
- параметр 1: doc_item (DocItem) — объект, для которого требуется сгенерировать документацию.

**Описание кода**:
Функция generate_doc_for_a_single_item принимает объект DocItem и проверяет, нужно ли генерировать для него документацию. Если проверка показывает, что документация не требуется (согласно списку игнорируемых элементов), выводится соответствующее сообщение. В противном случае вызывается функция generate_doc у объекта chat_engine, генерируется документация, которая добавляется к содержимому doc_item, и статус элемента обновляется. В случае возникновения ошибки при генерации документации, статус элемента устанавливается как «документ не был сгенерирован», и выводится сообщение об ошибке.

Функция используется в методе first_generate, который инициализирует процесс генерации документации, и в методе run, который запускает процесс обновления документации. В методе run функция generate_doc_for_a_single_item вызывается для обработки элементов из списка задач, созданного на основе изменений в файловой структуре проекта.

**Примечание**:
При использовании функции generate_doc_for_a_single_item необходимо учитывать, что она может генерировать документацию только для тех элементов, которые не игнорируются согласно настройкам проекта. Также следует помнить, что функция может выдавать ошибки, поэтому необходимо предусмотреть обработку исключений при её вызове.
***
### FunctionDef first_generate(self)
**first_generate**: Функция first_generate инициирует процесс генерации документации для проекта.

**parameters**:
- нет явно указанных параметров.

**Описание кода**: Функция first_generate выполняет следующие действия:
1. Выводит сообщение о начале генерации документации.
2. Определяет функцию check_task_available_func для проверки доступности задач на основе настроек проекта.
3. Создаёт объект task_manager для управления задачами.
4. Проверяет, находится ли процесс генерации документации в активном состоянии. Если нет, то устанавливает соответствующий флаг и выводит сообщение об инициализации нового списка задач. В противном случае выводит сообщение о загрузке из существующего списка задач.
5. Вызывает функцию generate_doc_for_a_single_item для обработки задач в task_manager.
6. Обновляет версию документации.
7. Завершает процесс генерации документации и выводит соответствующее сообщение.
8. В случае возникновения ошибки выводит сообщение об ошибке и количество сгенерированных документов на момент ошибки.

Функция используется в контексте обработки файлов в проекте, где требуется обновить документацию. Она вызывается для инициализации процесса генерации документации при запуске метода run.

**Примечание**: При использовании функции first_generate необходимо учитывать, что она может генерировать документацию только для тех элементов, которые не игнорируются согласно настройкам проекта. Также следует помнить, что функция может выдавать ошибки, поэтому необходимо предусмотреть обработку исключений при её вызове.
***
### FunctionDef markdown_refresh(self)
**markdown_refresh**: Функция `markdown_refresh` обновляет документы в формате Markdown для всех файлов в проекте.

**parameters**:
* параметр 1: нет явно указанных параметров.

**Описание кода**: Функция `markdown_refresh` выполняет следующие действия:
1. Получает доступ к папке markdown через объект `Path` и удаляет её содержимое, если оно существует.
2. Получает список всех файлов для обработки через `meta_info.get_all_files()`.
3. Для каждого файла проверяет наличие документации с помощью функции `recursive_check`.
4. Если документация отсутствует, пропускает файл.
5. Если документация есть, преобразует её в строку в формате Markdown с помощью функции `to_markdown`.
6. Создаёт файл с расширением `.md` для каждого обработанного файла.
7. Записывает преобразованную документацию в созданные файлы.
8. Логирует информацию о процессе обновления документов.

Функция `markdown_refresh` вызывается в контексте обработки файлов в проекте, где требуется преобразовать файлы в формат Markdown. Она используется для обновления документов в формате Markdown на основе содержимого файлов в проекте.

**Примечание**: При использовании функции `markdown_refresh` необходимо убедиться, что папка для markdown документов существует и что операция записи файлов не вызовет ошибок.
***
### FunctionDef to_markdown(self, item)
**to_markdown**: Функция to_markdown преобразует объект в строку в формате Markdown.

**parameters**:
- параметр 1: item — объект, который нужно преобразовать.
- параметр 2: now_level — текущий уровень вложенности объекта.

**Описание кода**:
Функция to_markdown принимает объект item и текущий уровень вложенности now_level. Она создаёт строку markdown_content, которая начинается с #, повторяющихся now_level раз, и содержит имя типа объекта item.item_type.to_str() и имя объекта item.obj_name. Если у объекта есть параметры, они добавляются в строку в виде списка через запятую. Затем функция проверяет, есть ли у объекта содержимое в формате Markdown (item.md_content), и если есть, добавляет его в строку. Если содержимого в формате Markdown нет, добавляется сообщение «Doc is waiting to be generated...». Затем функция рекурсивно вызывает себя для каждого дочернего объекта item.children и добавляет результаты в строку.

Функция вызывается из функции markdown_refresh, которая обрабатывает все файлы в проекте и создаёт для них документы в формате Markdown. Для каждого файла функция markdown_refresh вызывает to_markdown для каждого дочернего объекта и создаёт строку markdown, которая затем записывается в файл в формате Markdown.

**Примечание**:
При использовании функции to_markdown важно учитывать структуру объекта item и наличие у него параметров и содержимого в формате Markdown. Также стоит обратить внимание на то, что функция рекурсивно вызывает себя для дочерних объектов, что может повлиять на структуру и содержание создаваемого документа.
***
### FunctionDef git_commit(self, commit_message)
**git_commit**: Функция `git_commit` выполняет коммит изменений в репозитории Git с использованием переданного сообщения коммита.

**parameters**:
- `commit_message`: Строка, содержащая сообщение коммита, которое будет использовано при выполнении коммита в Git.

**Описание кода**:
Функция `git_commit` использует модуль `subprocess` для вызова команды `git commit` в системе. Параметр `shell=True` позволяет выполнить команду как скрипт в командной оболочке. Опция `--no-verify` указывает Git не запускать скрипты предварительной фиксации.

Сообщение коммита передаётся через параметр `commit_message`, который должен быть строкой. Функция пытается выполнить коммит, и в случае успешного выполнения ничего не выводит. Если возникает ошибка при выполнении команды, она перехватывается и выводится сообщение об ошибке с информацией о произошедшей ошибке.

**Примечание**:
При использовании функции `git_commit` необходимо убедиться, что в системе установлен и настроен Git. Также важно проверить корректность переданного сообщения коммита, чтобы избежать ошибок при выполнении коммита в репозитории.
***
### FunctionDef run(self)
**run**: Функция run запускает процесс обновления документации в проекте.

**parameters**: нет явно указанных параметров.

**Описание кода**: функция run выполняет следующие действия:
1. Проверяет, является ли версия документа пустой. Если да, то вызывает метод first_generate для инициализации процесса генерации документации.
2. Если версия документа не пустая и процесс генерации документации не находится в активном состоянии, выводит сообщение о начале обнаружения изменений.
3. Создаёт список файлов для обработки и обновляет информацию о метаданных проекта.
4. Определяет функцию check_task_available_func для проверки доступности задач на основе настроек проекта.
5. Создаёт объект task_manager для управления задачами.
6. Выводит список задач.
7. Вызывает функцию generate_doc_for_a_single_item для обработки задач в task_manager.
8. Обновляет версию документации.
9. Завершает процесс генерации документации и выводит соответствующее сообщение.
10. Обновляет документы в формате Markdown для всех файлов в проекте.
11. Выводит сообщение об успешном завершении процесса обновления документации.

Функция используется для автоматического обновления документации в проекте на основе изменений в файловой структуре. Она запускается при необходимости обновления документации.

**Примечание**: при использовании функции run необходимо учитывать, что она может генерировать документацию только для тех элементов, которые не игнорируются согласно настройкам проекта. Также следует помнить, что функция может выдавать ошибки, поэтому необходимо предусмотреть обработку исключений при её вызове.
***
### FunctionDef add_new_item(self, file_handler, json_data)
**add_new_item**: Функция `add_new_item` добавляет новые проекты в файл JSON и генерирует соответствующую документацию.

**parameters**:
* параметр 1: `file_handler` (FileHandler) — объект файлового обработчика для чтения и записи файлов.
* параметр 2: `json_data` (dict) — словарь, хранящий информацию о структуре проекта в формате JSON.

**Описание кода**: функция `add_new_item` проходит по файловому обработчику, извлекает информацию о функциях и классах из файла, генерирует документацию для каждой структуры и сохраняет результаты в словарь `file_dict`. Затем словарь `file_dict` добавляется в `json_data`, который записывается в файл в формате JSON. После этого функция создаёт файл Markdown с документацией для добавленного файла.

Функция `add_new_item` вызывается в контексте обработки файлов в проекте, где требуется добавить новый файл. Для этого используется файловый обработчик `file_handler` и словарь `json_data`.

Функция `add_new_item` взаимодействует с другими функциями и объектами, такими как `get_functions_and_classes`, `get_obj_code_info`, `generate_doc`, `convert_to_markdown_file` и `write_file`.

**Примечание**: при использовании функции `add_new_item` необходимо убедиться, что файловый обработчик `file_handler` и словарь `json_data` настроены корректно, чтобы избежать ошибок в дальнейшей обработке файлов.
***
### FunctionDef process_file_changes(self, repo_path, file_path, is_new_file)
**process_file_changes**: Функция process_file_changes обрабатывает изменённые файлы в соответствии с абсолютным путём к файлу, включая новые файлы и существующие файлы.

**parameters**:
* параметр 1: repo_path (str) — путь к репозиторию.
* параметр 2: file_path (str) — относительный путь к файлу.
* параметр 3: is_new_file (bool) — указывает, является ли файл новым или нет.

**Описание кода**: функция process_file_changes использует объект FileHandler для чтения файла по заданному пути. Затем она использует change_detector для анализа изменений в файле и идентификации изменений в структуре. Результаты анализа сохраняются в словаре changes_in_pyfile.

Далее функция проверяет, существует ли файл в словаре json_data, который содержит информацию о структуре проекта в формате JSON. Если файл существует, его структура обновляется с использованием функции update_existing_item. Если файл новый, он добавляется в json_data с помощью функции add_new_item.

После обновления структуры проекта функция записывает изменённый json_data обратно в файл. Затем она преобразует структуру файла в формат Markdown и записывает полученный текст в соответствующий файл.

Если в результате анализа изменений были добавлены файлы, которые ещё не были добавлены в систему контроля версий, функция добавляет их с помощью change_detector.add_unstaged_files.

**Примечание**: при использовании функции process_file_changes необходимо убедиться, что пути к репозиторию и файлу указаны корректно, а также что объекты change_detector и project_manager настроены правильно.
***
### FunctionDef update_existing_item(self, file_dict, file_handler, changes_in_pyfile)
**update_existing_item**: Функция update_existing_item обновляет существующие проекты, обрабатывая изменения в файлах.

**parameters**:
* параметр 1: `file_dict` (dict) — словарь, содержащий информацию о структуре файлов.
* параметр 2: `file_handler` (FileHandler) — объект файлового обработчика.
* параметр 3: `changes_in_pyfile` (dict) — словарь, содержащий информацию об объектах, которые были изменены в файле.

**Описание кода**: Функция `update_existing_item` использует объект `file_handler` для получения текущей структуры файла. Затем она обрабатывает объекты, которые были удалены из файла (`del_obj`), удаляя соответствующие ключи из `file_dict`. Для каждого объекта в текущей структуре файла (`current_objects`) функция обновляет соответствующие поля в `file_dict`, такие как тип объекта, номера строк начала и конца кода, родительский объект и номер столбца имени. Также функция создаёт список `referencer_list`, содержащий информацию о ссылках на объекты, которые были добавлены в файл. Затем с помощью `ThreadPoolExecutor` и `submit` вызывается `update_object` для каждого объекта, который был добавлен в файл.

Функция возвращает `file_dict` с обновлённой информацией о структуре файла.

Функция `update_existing_item` вызывается из `process_file_changes`, которая обрабатывает изменённые файлы в соответствии с абсолютным путём к файлу. `process_file_changes` использует `update_existing_item` для обновления существующей информации о файлах в иерархии проектов.

**Примечание**: При использовании функции `update_existing_item` важно убедиться, что объект `file_handler` правильно настроен и имеет доступ к нужным файлам. Также необходимо учитывать, что функция предполагает наличие предыдущих версий файла для сравнения и корректной работы с `changes_in_pyfile`.
***
### FunctionDef update_object(self, file_dict, file_handler, obj_name, obj_referencer_list)
**update_object**: Функция update_object обновляет информацию об объекте в соответствии с новыми данными, сгенерированными чат-движком.

**parameters**:
- параметр 1: file_dict (dict) — словарь, содержащий старую информацию об объекте.
- параметр 2: file_handler — обработчик файла.
- параметр 3: obj_name (str) — имя объекта.
- параметр 4: obj_referencer_list (list) — список объектов-ссылок.

**Описание кода**: Функция update_object проверяет, существует ли объект с именем obj_name в словаре file_dict. Если объект найден, то с помощью метода generate_doc чат-движка генерируется новое содержимое документации для этого объекта. Затем обновлённое содержимое сохраняется в словаре file_dict в поле md_content объекта obj.

Функция вызывается из update_existing_item, которая обновляет существующие проекты. В update_existing_item создаётся список referencer_list, содержащий информацию о ссылках на объекты, которые были добавлены в файл. Затем с помощью ThreadPoolExecutor и submit вызывается update_object для каждого объекта, который был добавлен в файл.

**Примечание**: При использовании функции update_object необходимо убедиться, что словарь file_dict содержит корректную информацию об объектах, а файл_handler настроен правильно для работы с файлом. Также важно учесть, что функция update_object изменяет словарь file_dict, поэтому необходимо предусмотреть соответствующие меры для сохранения изменений.
***
### FunctionDef get_new_objects(self, file_handler)
**get_new_objects**: Функция `get_new_objects` получает добавленные и удалённые объекты, сравнивая текущую версию и предыдущую версию .py файла.

**parameters**:
* параметр 1: `file_handler` (FileHandler): объект файлового обработчика.

**Описание кода**:
Функция `get_new_objects` использует объект `file_handler` для получения текущей и предыдущей версий .py файла. Затем она извлекает функции и классы из каждой версии и сравнивает их, чтобы определить, какие объекты были добавлены или удалены. Для этого используются множества, чтобы найти разницу между объектами в текущей и предыдущей версиях.

Функция возвращает кортеж, содержащий два списка: `new_obj` (добавленные объекты) и `del_obj` (удалённые объекты).

Эта функция вызывается в контексте обновления структуры файлов и управления изменениями в объектах. Она помогает отслеживать и применять изменения в файлах, что важно для корректной работы системы управления проектами.

**Примечание**:
При использовании функции `get_new_objects` важно убедиться, что объект `file_handler` правильно настроен и имеет доступ к нужным файлам. Также необходимо учитывать, что функция предполагает наличие предыдущих версий файла для сравнения.

**Output Example**:
```
new_obj: ['add_context_stack', '__init__']
del_obj: []
```
***
